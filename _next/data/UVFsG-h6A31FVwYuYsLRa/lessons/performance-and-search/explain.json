{"pageProps":{"post":{"attributes":{"title":"EXPLAIN"},"html":"<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\nPRAGMA index_list(<span class=\"hljs-string\">&#x27;Track&#x27;</span>);\nEXPLAIN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\nEXPLAIN QUERY PLAN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\n<span class=\"hljs-keyword\">CREATE</span> INDEX idx_track_name <span class=\"hljs-keyword\">ON</span> Track (Name);\nEXPLAIN QUERY PLAN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\nPRAGMA index_list(<span class=\"hljs-string\">&#x27;Track&#x27;</span>);\n</code></pre><p>Generally speaking, SQLite is extremely fast even on large datasets. It does a great job of working with large amounts of data even on complicated queries. However occasionally it can use some help when you have heavy queries that you run frequently. Let&#39;s first understand how to look at queries using some fun features built into SQLite.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\n</code></pre><p>Let&#39;s say we are building an interface that frequently needs to look up tracks by their names. You&#39;d be running queries like this frequently. Right now our Track database has some 3,000 rows in it but imagine if you had Spotify&#39;s database of music. Spotify says it has over 100,000,000 tracks on it, so that query get very slow. Let&#39;s see a few of the ways that SQLite gives you to inspect your queries.</p>\n<pre><code class=\"hljs language-sql\">EXPLAIN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\n</code></pre><pre><code>addr  opcode         p1    p2    p3    p4             p5  comment\n----  -------------  ----  ----  ----  -------------  --  -------------\n0     Init           0     17    0                    0   Start at 17\n1     OpenRead       0     409   0     9              0   root=409 iDb=0; Track\n2     Rewind         0     16    0                    0\n3       Column         0     1     1                    0   r[1]= cursor 0 column 1\n4       Ne             2     15    1     BINARY-8       82  if r[1]!=r[2] goto 15\n5       Rowid          0     3     0                    0   r[3]=Track.rowid\n6       Column         0     1     4                    0   r[4]= cursor 0 column 1\n7       Column         0     2     5                    0   r[5]= cursor 0 column 2\n8       Column         0     3     6                    0   r[6]= cursor 0 column 3\n9       Column         0     4     7                    0   r[7]= cursor 0 column 4\n10      Column         0     5     8                    0   r[8]= cursor 0 column 5\n11      Column         0     6     9                    0   r[9]= cursor 0 column 6\n12      Column         0     7     10                   0   r[10]= cursor 0 column 7\n13      Column         0     8     11                   0   r[11]= cursor 0 column 8\n14      ResultRow      3     9     0                    0   output=r[3..11]\n15    Next           0     3     0                    1\n16    Halt           0     0     0                    0\n17    Transaction    0     0     66    0              1   usesStmtJournal=0\n18    String8        0     2     0     Black Dog      0   r[2]=&#x27;Black Dog&#x27;\n19    Goto           0     1     0                    0\n</code></pre><p>I&#39;ll be honest, I understand like zero of this. This is what SQLite is doing under the hood. I found the input from Postgres&#39;s explain to be much more readable and actionable. In any case, it&#39;s there and you can anaylze it if you want to. I never look at this so I just wanted to show you that it&#39;s there.</p>\n<p>Instead, I use this</p>\n<pre><code class=\"hljs language-sql\">EXPLAIN QUERY PLAN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\n<span class=\"hljs-comment\">-- `--SCAN Track</span>\n</code></pre><p>Critically, the word <code>SCAN</code> here lets you know that this query is going to look at <em>every</em> row in the table. Now, if you only have 3,000 rows or you only run this query infrequently, who cares, a SCAN is fine. However, if you&#39;re Spotify and you&#39;re scanning 100,000,000 rows every search, then yes, you need to do something about this.</p>\n<p>One more fun trick if you&#39;re playing around in the CLI:</p>\n<pre><code class=\"hljs language-sql\">.eqp <span class=\"hljs-keyword\">on</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\n</code></pre><p>If you run <code>.eqp on</code>, for the rest of your session it will always show you the query plan when it runs a query. Can be kinda cool to see how SQLite chooses to plan queries.</p>\n","markdown":"\n```sql\nSELECT * FROM Track Where name ='Black Dog';\nPRAGMA index_list('Track');\nEXPLAIN SELECT * FROM Track Where name ='Black Dog';\nEXPLAIN QUERY PLAN SELECT * FROM Track Where name ='Black Dog';\nCREATE INDEX idx_track_name ON Track (Name);\nEXPLAIN QUERY PLAN SELECT * FROM Track Where name ='Black Dog';\nPRAGMA index_list('Track');\n```\n\nGenerally speaking, SQLite is extremely fast even on large datasets. It does a great job of working with large amounts of data even on complicated queries. However occasionally it can use some help when you have heavy queries that you run frequently. Let's first understand how to look at queries using some fun features built into SQLite.\n\n```sql\nSELECT * FROM Track Where name ='Black Dog';\n```\n\nLet's say we are building an interface that frequently needs to look up tracks by their names. You'd be running queries like this frequently. Right now our Track database has some 3,000 rows in it but imagine if you had Spotify's database of music. Spotify says it has over 100,000,000 tracks on it, so that query get very slow. Let's see a few of the ways that SQLite gives you to inspect your queries.\n\n```sql\nEXPLAIN SELECT * FROM Track Where name ='Black Dog';\n```\n\n```\naddr  opcode         p1    p2    p3    p4             p5  comment\n----  -------------  ----  ----  ----  -------------  --  -------------\n0     Init           0     17    0                    0   Start at 17\n1     OpenRead       0     409   0     9              0   root=409 iDb=0; Track\n2     Rewind         0     16    0                    0\n3       Column         0     1     1                    0   r[1]= cursor 0 column 1\n4       Ne             2     15    1     BINARY-8       82  if r[1]!=r[2] goto 15\n5       Rowid          0     3     0                    0   r[3]=Track.rowid\n6       Column         0     1     4                    0   r[4]= cursor 0 column 1\n7       Column         0     2     5                    0   r[5]= cursor 0 column 2\n8       Column         0     3     6                    0   r[6]= cursor 0 column 3\n9       Column         0     4     7                    0   r[7]= cursor 0 column 4\n10      Column         0     5     8                    0   r[8]= cursor 0 column 5\n11      Column         0     6     9                    0   r[9]= cursor 0 column 6\n12      Column         0     7     10                   0   r[10]= cursor 0 column 7\n13      Column         0     8     11                   0   r[11]= cursor 0 column 8\n14      ResultRow      3     9     0                    0   output=r[3..11]\n15    Next           0     3     0                    1\n16    Halt           0     0     0                    0\n17    Transaction    0     0     66    0              1   usesStmtJournal=0\n18    String8        0     2     0     Black Dog      0   r[2]='Black Dog'\n19    Goto           0     1     0                    0\n```\n\nI'll be honest, I understand like zero of this. This is what SQLite is doing under the hood. I found the input from Postgres's explain to be much more readable and actionable. In any case, it's there and you can anaylze it if you want to. I never look at this so I just wanted to show you that it's there.\n\nInstead, I use this\n\n```sql\nEXPLAIN QUERY PLAN SELECT * FROM Track Where name ='Black Dog';\n-- `--SCAN Track\n```\n\nCritically, the word `SCAN` here lets you know that this query is going to look at _every_ row in the table. Now, if you only have 3,000 rows or you only run this query infrequently, who cares, a SCAN is fine. However, if you're Spotify and you're scanning 100,000,000 rows every search, then yes, you need to do something about this.\n\nOne more fun trick if you're playing around in the CLI:\n\n```sql\n.eqp on\nSELECT * FROM Track Where name ='Black Dog';\n```\n\nIf you run `.eqp on`, for the rest of your session it will always show you the query plan when it runs a query. Can be kinda cool to see how SQLite chooses to plan queries.\n","slug":"explain","title":"EXPLAIN","section":"Performance and Search","icon":"gauge-high","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/07-performance-and-search/A-explain.md","nextSlug":"/lessons/performance-and-search/indexes","prevSlug":"/lessons/what-is-unique-to-sqlite/views"}},"__N_SSG":true}