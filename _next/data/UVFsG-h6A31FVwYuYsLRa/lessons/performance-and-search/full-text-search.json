{"pageProps":{"post":{"attributes":{},"html":"<p>What if you&#39;re building an app and you want to be able to search for &quot;black&quot; you expect to get the results Amy Winehouse&#39;s &quot;Back to Black&quot;, the band Black Sabbath, and Metallica&#39;s &quot;Black Album&quot;. Those are three different columns! We could write three LIKE queries or try to hack it around it with something similar, but luckily there&#39;s something that already exists, FTS. FTS stands for full text search and we&#39;re going to be using version 5 of it, FTS5. FTS5 is technically an extension (like the JSON one we&#39;re about to use) but FTS5 is actually shipped bundled in with SQLite now.</p>\n<p>FTS5 allows you to run queries that look like <code>SELECT * FROM track_search WHERE track_search MATCH &#39;black&#39;</code>. We get to use MATCH to tell FTS5 to look across its columns. Really cool, right?</p>\n<p>Alright, let&#39;s re-use that View we used earlier (easy_tracks). If you don&#39;t have it anymore, here&#39;s the query to recreate it.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">VIEW</span> IF <span class=\"hljs-keyword\">EXISTS</span> easy_tracks;\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span>\n  easy_tracks\n<span class=\"hljs-keyword\">AS</span>\n\n<span class=\"hljs-keyword\">SELECT</span>\n  t.TrackId <span class=\"hljs-keyword\">as</span> id,\n  ar.Name <span class=\"hljs-keyword\">as</span> artist,\n  al.Title <span class=\"hljs-keyword\">as</span> album,\n  t.Name <span class=\"hljs-keyword\">as</span> track\n<span class=\"hljs-keyword\">FROM</span>\n  Track t\n\n<span class=\"hljs-keyword\">JOIN</span>\n  Album al\n<span class=\"hljs-keyword\">ON</span>\n  t.AlbumId <span class=\"hljs-operator\">=</span> al.AlbumId\n\n<span class=\"hljs-keyword\">JOIN</span>\n  Artist ar\n<span class=\"hljs-keyword\">ON</span>\n  ar.ArtistId <span class=\"hljs-operator\">=</span> al.ArtistId;\n</code></pre><p>Then we need to create the virtual table that will contain the full text search.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> VIRTUAL <span class=\"hljs-keyword\">TABLE</span> track_search <span class=\"hljs-keyword\">USING</span> FTS5(content<span class=\"hljs-operator\">=</span>&quot;easy_tracks&quot;, content_rowid<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;id&#x27;</span>, track, album, artist);\n</code></pre><ul>\n<li>We have to identify where the content is going to com from which will be a table. This table won&#39;t actually contain the rows but only the text searchable table that will have a rowid (which we identified as id; if you just call it rowid we don&#39;t have to tell it which rowid to use.)</li>\n<li>We tell it what rows we want to include in full text search. Let&#39;s say we had producers in that table as well but we didn&#39;t want that to be searchable. No problem, you could write a query to select producers that have <code>MATCH &#39;black&#39;</code> and that still works fine! As long as it&#39;s in the view/table you&#39;re selecting from.</li>\n<li>We&#39;re choosing to index the view we created earlier but you can definitely do it on normal tables as well.</li>\n</ul>\n<p>Okay, so because the table doesn&#39;t include the rows itself, we actually have to go populate it. We have to continually keep it up to date because <a href=\"https://www.sqlite.org/fts5.html#external_content_and_contentless_tables\">it does not automatically sync</a> (unlike a view.)</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> track_search <span class=\"hljs-keyword\">SELECT</span> album, artist, track <span class=\"hljs-keyword\">FROM</span> easy_tracks;\n</code></pre><p>This is the fastest way. We just use a select statement to grab the correct bits of info and dump it directly into track_search. In theory you could just create a cron job to continually update the virtual table every hour/day/week or whatever meets your customers&#39; needs.</p>\n<p>You could get extra fancy and do it with TRIGGERs which we&#39;re not going to cover in this course. If you want to see that, <a href=\"https://stackoverflow.com/a/69981377\">this StackOverflow answer</a> explains exactly how to. If you do that it&#39;ll automatically keep your FTS5 table in sync with your view.</p>\n<p>Okay, so let&#39;s run some queries!</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> track_search <span class=\"hljs-keyword\">WHERE</span> track_search <span class=\"hljs-keyword\">MATCH</span> <span class=\"hljs-string\">&#x27;black&#x27;</span>;\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> track_search <span class=\"hljs-keyword\">WHERE</span> track_search <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;white&#x27;</span>;\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> track_search(<span class=\"hljs-string\">&#x27;red&#x27;</span>);\n</code></pre><p>All of these are valid ways of writing the same query. I tend to use the <code>MATCH</code> syntax as it&#39;s very clear that it&#39;s a FTS query.</p>\n<h2>There&#39;s more than just match</h2>\n<p>I showed you just one of the ways to use MATCH but there&#39;s actually a whole myriad of ways to use it. <a href=\"https://www.sqlite.org/fts5.html#full_text_query_syntax\">Click here</a> to read more of the docs of how you can use special syntax to select words that begin with the search term, ends with it, etc.</p>\n<h2>bm25()</h2>\n<p>Generally you will want the &quot;best&quot; matches to show up first and the worst matches to show up last. SQLite provides a the bm25 function to do this.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> bm25(track_search), <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> track_search <span class=\"hljs-keyword\">WHERE</span> track_search <span class=\"hljs-keyword\">MATCH</span> <span class=\"hljs-string\">&#x27;black&#x27;</span> <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> bm25(track_search);\n</code></pre><p>The smaller the number is (or the more negative) the better the match is. So this query will give you back all of the matches in order. If you want to learn more or see how the math is done, <a href=\"https://www.sqlite.org/fts5.html#the_bm25_function\">the docs</a> are the best place to look.</p>\n","markdown":"What if you're building an app and you want to be able to search for \"black\" you expect to get the results Amy Winehouse's \"Back to Black\", the band Black Sabbath, and Metallica's \"Black Album\". Those are three different columns! We could write three LIKE queries or try to hack it around it with something similar, but luckily there's something that already exists, FTS. FTS stands for full text search and we're going to be using version 5 of it, FTS5. FTS5 is technically an extension (like the JSON one we're about to use) but FTS5 is actually shipped bundled in with SQLite now.\n\nFTS5 allows you to run queries that look like `SELECT * FROM track_search WHERE track_search MATCH 'black'`. We get to use MATCH to tell FTS5 to look across its columns. Really cool, right?\n\nAlright, let's re-use that View we used earlier (easy_tracks). If you don't have it anymore, here's the query to recreate it.\n\n```sql\nDROP VIEW IF EXISTS easy_tracks;\nCREATE VIEW\n  easy_tracks\nAS\n\nSELECT\n  t.TrackId as id,\n  ar.Name as artist,\n  al.Title as album,\n  t.Name as track\nFROM\n  Track t\n\nJOIN\n  Album al\nON\n  t.AlbumId = al.AlbumId\n\nJOIN\n  Artist ar\nON\n  ar.ArtistId = al.ArtistId;\n```\n\nThen we need to create the virtual table that will contain the full text search.\n\n```sql\nCREATE VIRTUAL TABLE track_search USING FTS5(content=\"easy_tracks\", content_rowid='id', track, album, artist);\n```\n\n- We have to identify where the content is going to com from which will be a table. This table won't actually contain the rows but only the text searchable table that will have a rowid (which we identified as id; if you just call it rowid we don't have to tell it which rowid to use.)\n- We tell it what rows we want to include in full text search. Let's say we had producers in that table as well but we didn't want that to be searchable. No problem, you could write a query to select producers that have `MATCH 'black'` and that still works fine! As long as it's in the view/table you're selecting from.\n- We're choosing to index the view we created earlier but you can definitely do it on normal tables as well.\n\nOkay, so because the table doesn't include the rows itself, we actually have to go populate it. We have to continually keep it up to date because [it does not automatically sync][sync] (unlike a view.)\n\n```sql\nINSERT INTO track_search SELECT album, artist, track FROM easy_tracks;\n```\n\nThis is the fastest way. We just use a select statement to grab the correct bits of info and dump it directly into track_search. In theory you could just create a cron job to continually update the virtual table every hour/day/week or whatever meets your customers' needs.\n\nYou could get extra fancy and do it with TRIGGERs which we're not going to cover in this course. If you want to see that, [this StackOverflow answer][stack-overflow] explains exactly how to. If you do that it'll automatically keep your FTS5 table in sync with your view.\n\nOkay, so let's run some queries!\n\n```sql\nSELECT * FROM track_search WHERE track_search MATCH 'black';\nSELECT * FROM track_search WHERE track_search = 'white';\nSELECT * FROM track_search('red');\n```\n\nAll of these are valid ways of writing the same query. I tend to use the `MATCH` syntax as it's very clear that it's a FTS query.\n\n## There's more than just match\n\nI showed you just one of the ways to use MATCH but there's actually a whole myriad of ways to use it. [Click here][syntax] to read more of the docs of how you can use special syntax to select words that begin with the search term, ends with it, etc.\n\n## bm25()\n\nGenerally you will want the \"best\" matches to show up first and the worst matches to show up last. SQLite provides a the bm25 function to do this.\n\n```sql\nSELECT bm25(track_search), * FROM track_search WHERE track_search MATCH 'black' ORDER BY bm25(track_search);\n```\n\nThe smaller the number is (or the more negative) the better the match is. So this query will give you back all of the matches in order. If you want to learn more or see how the math is done, [the docs][bm25] are the best place to look.\n\n[sync]: https://www.sqlite.org/fts5.html#external_content_and_contentless_tables\n[stack-overflow]: https://stackoverflow.com/a/69981377\n[syntax]: https://www.sqlite.org/fts5.html#full_text_query_syntax\n[bm25]: https://www.sqlite.org/fts5.html#the_bm25_function\n","slug":"full-text-search","title":"Full Text Search","section":"Performance and Search","icon":"gauge-high","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/07-performance-and-search/C-full-text-search.md","nextSlug":"/lessons/json/sqlite-extensions","prevSlug":"/lessons/performance-and-search/indexes"}},"__N_SSG":true}