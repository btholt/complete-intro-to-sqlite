{"pageProps":{"post":{"attributes":{},"html":"<p>Okay, so now we know we have a query we need to optimize. How do we do it? With an index!</p>\n<p>An index makes a B-Tree (which stands for balanced tree) to make look ups much faster. Instead of taking O(n) to do a lookup items, it takes O(log n) since it can use a tree to find the item instead of scanning every item in the database.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> INDEX idx_track_name <span class=\"hljs-keyword\">ON</span> Track (Name);\n\n<span class=\"hljs-comment\">-- see it&#x27;s there now</span>\nPRAGMA index_list(<span class=\"hljs-string\">&#x27;Track&#x27;</span>);\n\nEXPLAIN QUERY PLAN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\n<span class=\"hljs-comment\">-- `--SEARCH Track USING INDEX idx_track_name (Name=?)</span>\n</code></pre><p>Notice it&#39;s a SEARCH now instead of a SCAN. This means it was able to use an index and only look at a subset of the table instead of every row. Hooray!</p>\n<pre><code class=\"hljs language-sql\">EXPLAIN QUERY PLAN <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Track <span class=\"hljs-keyword\">Where</span> name <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;Black Dog&#x27;</span>;\n</code></pre><pre><code>-- w/ index\naddr  opcode         p1    p2    p3    p4             p5  comment\n----  -------------  ----  ----  ----  -------------  --  -------------\n0     Init           0     19    0                    0   Start at 19\n1     OpenRead       0     409   0     9              0   root=409 iDb=0; Track\n2     OpenRead       1     2     0     k(2,,)         2   root=2 iDb=0; idx_track_name\n3     String8        0     1     0     Black Dog      0   r[1]=&#x27;Black Dog&#x27;\n4     SeekGE         1     18    1     1              0   key=r[1]\n5       IdxGT          1     18    1     1              0   key=r[1]\n6       DeferredSeek   1     0     0                    0   Move 0 to 1.rowid if needed\n7       IdxRowid       1     2     0                    0   r[2]=rowid; Track.rowid\n8       Column         1     0     3                    0   r[3]= cursor 1 column 0\n9       Column         0     2     4                    0   r[4]= cursor 0 column 2\n10      Column         0     3     5                    0   r[5]= cursor 0 column 3\n11      Column         0     4     6                    0   r[6]= cursor 0 column 4\n12      Column         0     5     7                    0   r[7]= cursor 0 column 5\n13      Column         0     6     8                    0   r[8]= cursor 0 column 6\n14      Column         0     7     9                    0   r[9]= cursor 0 column 7\n15      Column         0     8     10                   0   r[10]= cursor 0 column 8\n16      ResultRow      2     9     0                    0   output=r[2..10]\n17    Next           1     5     1                    0\n18    Halt           0     0     0                    0\n19    Transaction    0     0     65    0              1   usesStmtJournal=0\n20    Goto           0     1     0                    0\n</code></pre><p>Again, I have a hard time reading this. You can see that it refers to the index in the comments so that&#39;s positive.</p>\n<p>Okay so let&#39;s talk a little bit more about why you may not to index everything. I&#39;ve heard the saying that indexes are like aspirin – they&#39;re a great help when you have a problem but if you use too many they become a problem.</p>\n<p>Every time you insert into a table that has indexes, it has to do some rebuilding of the indexes to accommodate this information. Likewise, if you delete, it has to move its nodes around its B-tree to keep it balanced. B-trees also take up space, and on large tables it can be non-trivial amounts of space. The trade-off here is that indexes help with reads but slow down updates, deletes, and inserts as well as take up space. In general I wait for a query to become a problem first before I try to index it, and even then I try to index only what I need to solve my problem. Pre-mature optimization generally is a bad thing to do because as developers we&#39;re pretty bad at guessing what&#39;s going to go wrong.</p>\n","markdown":"Okay, so now we know we have a query we need to optimize. How do we do it? With an index!\n\nAn index makes a B-Tree (which stands for balanced tree) to make look ups much faster. Instead of taking O(n) to do a lookup items, it takes O(log n) since it can use a tree to find the item instead of scanning every item in the database.\n\n```sql\nCREATE INDEX idx_track_name ON Track (Name);\n\n-- see it's there now\nPRAGMA index_list('Track');\n\nEXPLAIN QUERY PLAN SELECT * FROM Track Where name ='Black Dog';\n-- `--SEARCH Track USING INDEX idx_track_name (Name=?)\n```\n\nNotice it's a SEARCH now instead of a SCAN. This means it was able to use an index and only look at a subset of the table instead of every row. Hooray!\n\n```sql\nEXPLAIN QUERY PLAN SELECT * FROM Track Where name ='Black Dog';\n```\n\n```\n-- w/ index\naddr  opcode         p1    p2    p3    p4             p5  comment\n----  -------------  ----  ----  ----  -------------  --  -------------\n0     Init           0     19    0                    0   Start at 19\n1     OpenRead       0     409   0     9              0   root=409 iDb=0; Track\n2     OpenRead       1     2     0     k(2,,)         2   root=2 iDb=0; idx_track_name\n3     String8        0     1     0     Black Dog      0   r[1]='Black Dog'\n4     SeekGE         1     18    1     1              0   key=r[1]\n5       IdxGT          1     18    1     1              0   key=r[1]\n6       DeferredSeek   1     0     0                    0   Move 0 to 1.rowid if needed\n7       IdxRowid       1     2     0                    0   r[2]=rowid; Track.rowid\n8       Column         1     0     3                    0   r[3]= cursor 1 column 0\n9       Column         0     2     4                    0   r[4]= cursor 0 column 2\n10      Column         0     3     5                    0   r[5]= cursor 0 column 3\n11      Column         0     4     6                    0   r[6]= cursor 0 column 4\n12      Column         0     5     7                    0   r[7]= cursor 0 column 5\n13      Column         0     6     8                    0   r[8]= cursor 0 column 6\n14      Column         0     7     9                    0   r[9]= cursor 0 column 7\n15      Column         0     8     10                   0   r[10]= cursor 0 column 8\n16      ResultRow      2     9     0                    0   output=r[2..10]\n17    Next           1     5     1                    0\n18    Halt           0     0     0                    0\n19    Transaction    0     0     65    0              1   usesStmtJournal=0\n20    Goto           0     1     0                    0\n```\n\nAgain, I have a hard time reading this. You can see that it refers to the index in the comments so that's positive.\n\nOkay so let's talk a little bit more about why you may not to index everything. I've heard the saying that indexes are like aspirin – they're a great help when you have a problem but if you use too many they become a problem.\n\nEvery time you insert into a table that has indexes, it has to do some rebuilding of the indexes to accommodate this information. Likewise, if you delete, it has to move its nodes around its B-tree to keep it balanced. B-trees also take up space, and on large tables it can be non-trivial amounts of space. The trade-off here is that indexes help with reads but slow down updates, deletes, and inserts as well as take up space. In general I wait for a query to become a problem first before I try to index it, and even then I try to index only what I need to solve my problem. Pre-mature optimization generally is a bad thing to do because as developers we're pretty bad at guessing what's going to go wrong.\n","slug":"indexes","title":"Indexes","section":"Performance and Search","icon":"gauge-high","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/07-performance-and-search/B-indexes.md","nextSlug":"/lessons/performance-and-search/full-text-search","prevSlug":"/lessons/performance-and-search/explain"}},"__N_SSG":true}