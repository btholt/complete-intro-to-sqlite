{"pageProps":{"post":{"attributes":{},"html":"<p>We looked at several ways of doing joins in the last section by using the <code>JOIN</code> keyword. One key thing about that is we were doing <code>INNER JOIN</code>s. If you don&#39;t specify what type of join to do, it is implicitly an INNER JOIN. In practice it didn&#39;t matter because our queries matched up 1:1:</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    B.Name, A.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album A\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span>\n    Artist B <span class=\"hljs-keyword\">ON</span>\n        A.ArtistId <span class=\"hljs-operator\">=</span> B.ArtistId\nLIMIT\n    <span class=\"hljs-number\">5</span>;\n</code></pre><blockquote>\n<p><code>INNER JOIN</code> or just <code>JOIN</code> are the same thing.</p>\n</blockquote>\n<p><a href=\"https://commons.wikimedia.org/wiki/File:SQL_Joins.svg\"><img src=\"/images/SQL_Joins.png\" alt=\"diagram of SQL joins\"></a></p>\n<p>Our INNER JOIN is giving us the inner section on the Venn Diagram between the two tables. Let&#39;s say that we have an artist in the artist table that we don&#39;t have any albums for. If we just</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    B.Name, A.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album A\n<span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span>\n    Artist B <span class=\"hljs-keyword\">ON</span>\n        A.ArtistId <span class=\"hljs-operator\">=</span> B.ArtistId\n<span class=\"hljs-keyword\">WHERE</span>\n    B.Name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Snow Patrol&#x27;</span>;\n\n<span class=\"hljs-keyword\">SELECT</span>\n    B.Name, A.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album A\n<span class=\"hljs-keyword\">RIGHT</span> <span class=\"hljs-keyword\">JOIN</span>\n    Artist B <span class=\"hljs-keyword\">ON</span>\n        A.ArtistId <span class=\"hljs-operator\">=</span> B.ArtistId\n<span class=\"hljs-keyword\">WHERE</span>\n    B.Name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Snow Patrol&#x27;</span>;\n</code></pre><p>Notice the first query doesn&#39;t give us any results. That&#39;s because it&#39;s an inner join – it will only give us things from rows in <em>both</em> tables. Now if we run the second query, it&#39;ll give anything that&#39;s in the inner part (which is nothing, as we just saw) <em>and</em> it will give us anything that <em>just</em> exists in the Artist Table (the &quot;right&quot; table in this case.)</p>\n<blockquote>\n<p>LEFT refers to the FROM clause table, RIGHT refers to what comes from the JOIN.</p>\n</blockquote>\n<p>What if we wanted to see all artists without an album in the album table?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    B.Name, A.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album A\n<span class=\"hljs-keyword\">RIGHT</span> <span class=\"hljs-keyword\">OUTER</span> <span class=\"hljs-keyword\">JOIN</span>\n    Artist B <span class=\"hljs-keyword\">ON</span>\n        A.ArtistId <span class=\"hljs-operator\">=</span> B.ArtistId;\n</code></pre><p>That OUTER part means <em>only</em> take things that don&#39;t have anything in the Album table, so it will only give us artists with no albums in the albums table.</p>\n<h2>NATURAL JOIN</h2>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    B.Name, A.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album A\n<span class=\"hljs-keyword\">NATURAL</span> <span class=\"hljs-keyword\">JOIN</span>\n    Artist B\nLIMIT\n    <span class=\"hljs-number\">5</span>;\n\n<span class=\"hljs-keyword\">SELECT</span>\n    B.Name, A.Title, C.Name\n<span class=\"hljs-keyword\">FROM</span>\n    Album A\n<span class=\"hljs-keyword\">NATURAL</span> <span class=\"hljs-keyword\">JOIN</span>\n    Artist B\n<span class=\"hljs-keyword\">NATURAL</span> <span class=\"hljs-keyword\">JOIN</span>\n    Track C\nLIMIT\n    <span class=\"hljs-number\">5</span>;\n</code></pre><p>I don&#39;t really like NATURAL JOIN but I thought I&#39;d mention it because you&#39;ll see it from time to time. By saying NATURAL JOIN in this case, we&#39;re saying &quot;Hey, I have columns in both tables that are named the same thing. Using that, join these tables.&quot;</p>\n<p>It might seem convenient (and if you structure your tables well like Chinook is, it&#39;s easy) but it&#39;s so implicit. I don&#39;t like magic code and this feels magic and brittle. If you rename a column or drop it or anything like that, you can break your queries or, even worse, get the wrong data back. I&#39;d say steer clear.</p>\n","markdown":"We looked at several ways of doing joins in the last section by using the `JOIN` keyword. One key thing about that is we were doing `INNER JOIN`s. If you don't specify what type of join to do, it is implicitly an INNER JOIN. In practice it didn't matter because our queries matched up 1:1:\n\n```sql\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nINNER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nLIMIT\n    5;\n```\n\n> `INNER JOIN` or just `JOIN` are the same thing.\n\n[![diagram of SQL joins](/images/SQL_Joins.png)](https://commons.wikimedia.org/wiki/File:SQL_Joins.svg)\n\nOur INNER JOIN is giving us the inner section on the Venn Diagram between the two tables. Let's say that we have an artist in the artist table that we don't have any albums for. If we just\n\n```sql\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nINNER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nWHERE\n    B.Name = 'Snow Patrol';\n\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nRIGHT JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId\nWHERE\n    B.Name = 'Snow Patrol';\n```\n\nNotice the first query doesn't give us any results. That's because it's an inner join – it will only give us things from rows in _both_ tables. Now if we run the second query, it'll give anything that's in the inner part (which is nothing, as we just saw) _and_ it will give us anything that _just_ exists in the Artist Table (the \"right\" table in this case.)\n\n> LEFT refers to the FROM clause table, RIGHT refers to what comes from the JOIN.\n\nWhat if we wanted to see all artists without an album in the album table?\n\n```sql\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nRIGHT OUTER JOIN\n    Artist B ON\n        A.ArtistId = B.ArtistId;\n```\n\nThat OUTER part means _only_ take things that don't have anything in the Album table, so it will only give us artists with no albums in the albums table.\n\n## NATURAL JOIN\n\n```sql\nSELECT\n    B.Name, A.Title\nFROM\n    Album A\nNATURAL JOIN\n    Artist B\nLIMIT\n    5;\n\nSELECT\n    B.Name, A.Title, C.Name\nFROM\n    Album A\nNATURAL JOIN\n    Artist B\nNATURAL JOIN\n    Track C\nLIMIT\n    5;\n```\n\nI don't really like NATURAL JOIN but I thought I'd mention it because you'll see it from time to time. By saying NATURAL JOIN in this case, we're saying \"Hey, I have columns in both tables that are named the same thing. Using that, join these tables.\"\n\nIt might seem convenient (and if you structure your tables well like Chinook is, it's easy) but it's so implicit. I don't like magic code and this feels magic and brittle. If you rename a column or drop it or anything like that, you can break your queries or, even worse, get the wrong data back. I'd say steer clear.\n","slug":"other-types-of-joins","title":"Other Types of Joins","section":"Intermediate SQL","icon":"table","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/04-intermediate-sql/B-other-types-of-joins.md","nextSlug":"/lessons/intermediate-sql/foreign-keys","prevSlug":"/lessons/intermediate-sql/relational-data"}},"__N_SSG":true}