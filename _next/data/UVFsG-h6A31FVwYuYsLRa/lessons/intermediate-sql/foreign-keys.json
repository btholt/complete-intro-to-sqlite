{"pageProps":{"post":{"attributes":{},"html":"<p>We can actually make that relationship between IDs explicit. We can make it so <code>AlbumId</code> isn&#39;t just an implicit relationship but an actual relationship tracked by SQLite itself. This relationship is called a foreign key: a key that references foreign information in another table. Our Chinook database already has these relationships built in. Type <code>.schema Track</code> and notice the FOREIGN KEY part on MediaTypeId, GenreId, and AlbumId.</p>\n<blockquote>\n<p>SQLite does not enforce foreign key rules by default. Every time you open the database connection you need to tell it respect it with <code>PRAGMA foreign_keys=on;</code>. Yes, it&#39;s by connection, and no, there&#39;s no way to always turn it on. Probably my biggest complaint about SQLite. It&#39;s done for historical / compat reasons.</p>\n</blockquote>\n<pre><code class=\"hljs language-sql\">PRAGMA foreign_keys<span class=\"hljs-operator\">=</span><span class=\"hljs-keyword\">on</span>;\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span>\n    Track\n    (Name, AlbumId, MediaTypeId, Composer, Milliseconds, Bytes, UnitPrice)\n<span class=\"hljs-keyword\">VALUES</span>\n    (<span class=\"hljs-string\">&#x27;lol&#x27;</span>, <span class=\"hljs-number\">99999</span>, <span class=\"hljs-number\">99999</span>, <span class=\"hljs-number\">99999</span>, <span class=\"hljs-number\">99999</span>, <span class=\"hljs-number\">99999</span>, <span class=\"hljs-number\">99999</span>);\n\n<span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-keyword\">FROM</span>\n    Genre\n<span class=\"hljs-keyword\">WHERE</span>\n    GenreId<span class=\"hljs-operator\">=</span><span class=\"hljs-number\">24</span>;\n</code></pre><blockquote>\n<p>Both of those queries should fail due to foreign key constraints.</p>\n</blockquote>\n<ul>\n<li>PRAGMAs are basically policies you can tell SQLite to respect. In this case, we are saying for <em>this</em> connection, please enforce rules around foreign keys. You need to do this for every connection to SQLite. There&#39;s a bunch but I tend not to use too many of them.</li>\n<li>You can actually set the foreign key pragma in the connection string when you connect in code. I&#39;ll show you how later.</li>\n<li>Notice it won&#39;t let us neither insert with violations of the constraint nor delete.</li>\n<li>You can also do <code>ON UPDATE</code> constraints as well.</li>\n<li>We did a <code>NO ACTION</code> constraint, but there are others as well. NO ACTION means that if a foreign key relationship would be severed and thus leaving orphan rows, error out the query. <code>RESTRICT</code> does this as well (but has some minuet difference that has never been important to me.) <code>ON DELETE CASCADE</code> will delete any affected rows. So if I delete &quot;rock&quot; from the Genre table, it will go delete every rock track from the Track table. You can also do <code>ON DELETE SET NULL</code> and <code>ON DELETE SET DEFAULT</code> to just change the value.</li>\n</ul>\n","markdown":"We can actually make that relationship between IDs explicit. We can make it so `AlbumId` isn't just an implicit relationship but an actual relationship tracked by SQLite itself. This relationship is called a foreign key: a key that references foreign information in another table. Our Chinook database already has these relationships built in. Type `.schema Track` and notice the FOREIGN KEY part on MediaTypeId, GenreId, and AlbumId.\n\n> SQLite does not enforce foreign key rules by default. Every time you open the database connection you need to tell it respect it with `PRAGMA foreign_keys=on;`. Yes, it's by connection, and no, there's no way to always turn it on. Probably my biggest complaint about SQLite. It's done for historical / compat reasons.\n\n```sql\nPRAGMA foreign_keys=on;\n\nINSERT INTO\n    Track\n    (Name, AlbumId, MediaTypeId, Composer, Milliseconds, Bytes, UnitPrice)\nVALUES\n    ('lol', 99999, 99999, 99999, 99999, 99999, 99999);\n\nDELETE FROM\n    Genre\nWHERE\n    GenreId=24;\n```\n\n> Both of those queries should fail due to foreign key constraints.\n\n- PRAGMAs are basically policies you can tell SQLite to respect. In this case, we are saying for _this_ connection, please enforce rules around foreign keys. You need to do this for every connection to SQLite. There's a bunch but I tend not to use too many of them.\n- You can actually set the foreign key pragma in the connection string when you connect in code. I'll show you how later.\n- Notice it won't let us neither insert with violations of the constraint nor delete.\n- You can also do `ON UPDATE` constraints as well.\n- We did a `NO ACTION` constraint, but there are others as well. NO ACTION means that if a foreign key relationship would be severed and thus leaving orphan rows, error out the query. `RESTRICT` does this as well (but has some minuet difference that has never been important to me.) `ON DELETE CASCADE` will delete any affected rows. So if I delete \"rock\" from the Genre table, it will go delete every rock track from the Track table. You can also do `ON DELETE SET NULL` and `ON DELETE SET DEFAULT` to just change the value.\n","slug":"foreign-keys","title":"Foreign Keys","section":"Intermediate SQL","icon":"table","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/04-intermediate-sql/C-foreign-keys.md","nextSlug":"/lessons/intermediate-sql/aggregation","prevSlug":"/lessons/intermediate-sql/other-types-of-joins"}},"__N_SSG":true}