{"pageProps":{"post":{"attributes":{},"html":"<p>So far we&#39;ve done a one-to-one matching of records. We&#39;ve used a record in a database to represent one item: one band member, band, etc.</p>\n<p>Now we&#39;re going to get into records that can relate to each other. Let&#39;s think about albums. An album has multiple tracks. That <strong>has</strong> word is key here. It means there is a relationship. A single album has many tracks. This is a one-to-many relationship – one album has multiple tracks. Those tracks belong to that album. A track does not belong to multiple albums (in theory you could model this differently but let&#39;s say we choose to model it this way.)</p>\n<p>A band member can belong to multiple bands, and a band has multiple members. Dave Grohl has been in Nirvana, Foo Fighters, and Them Crooked Vultures. This kind of relationship is called many-to-many. Recipes and ingredients would be another good example of this. A recipe has many ingredients, and an ingredient can belong to many recipes.</p>\n<p>There can also exist one-to-one relationships but in general, you would just make those the same record altogether. You could split up the type and title into two tables, but why would you? Then you have a data sync problem. What if a band renames themselves? Ex: On a Friday → Radiohead, Prince → The Artist Formerly Known as Prince, The Quarrymen → The Beatles. Anyone who has ever tried to manually keep data in sync in two+ places knows eventually you will have issues.</p>\n<p>Luckily we can use relational data to have one table of bands and one table of albums.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Album LIMIT <span class=\"hljs-number\">5</span>;\n</code></pre><p>Notice that we&#39;re just getting ArtistId (a number) instead of the actual name of the band. That&#39;s not what we want, we want to see the name of the album and the name of the band. Enter JOINs. This allows us to join two tables based on common data. Let&#39;s see how to do that.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    Artist.Name, Album.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album\n<span class=\"hljs-keyword\">JOIN</span>\n    Artist <span class=\"hljs-keyword\">ON</span>\n        Album.ArtistId <span class=\"hljs-operator\">=</span> Artist.ArtistId\nLIMIT <span class=\"hljs-number\">5</span>;\n</code></pre><blockquote>\n<p>Once we start getting into longer queries (especially when in code) I start spacing it out using new lines to make it easier to read. Makes it easier to understand at a glance.</p>\n</blockquote>\n<p>We JOIN&#39;d the Artist table to the Album table based on them sharing a common ArtistId. Pretty cool, right? Let&#39;s look at a few more tricks here.</p>\n<h2>Table Aliases</h2>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    b.Name, a.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album a\n<span class=\"hljs-keyword\">JOIN</span>\n    Artist b <span class=\"hljs-keyword\">ON</span>\n        a.ArtistId <span class=\"hljs-operator\">=</span> b.ArtistId\nLIMIT <span class=\"hljs-number\">5</span>;\n</code></pre><p>You can give tables aliases so they&#39;re easier to refer to. Some of the table names can get quite long so this can make it more readable. In this case, I&#39;d argue that the single-letter variable names make it <em>less</em> readable, that&#39;s up to you.</p>\n<h2>You can use WHERE!</h2>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    Artist.Name, Album.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album\n<span class=\"hljs-keyword\">JOIN</span>\n    Artist <span class=\"hljs-keyword\">ON</span>\n        Album.ArtistId <span class=\"hljs-operator\">=</span> Artist.ArtistId\n<span class=\"hljs-keyword\">WHERE</span>\n    Artist.Name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Nirvana&#x27;</span>;\n\n<span class=\"hljs-keyword\">SELECT</span>\n    Artist.Name, Album.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album\n<span class=\"hljs-keyword\">JOIN</span>\n    Artist <span class=\"hljs-keyword\">ON</span>\n        Album.ArtistId <span class=\"hljs-operator\">=</span> Artist.ArtistId\n<span class=\"hljs-keyword\">WHERE</span>\n    Album.Title <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;IV&#x27;</span>;\n\n<span class=\"hljs-keyword\">SELECT</span>\n    Artist.Name, Album.Title\n<span class=\"hljs-keyword\">FROM</span>\n    Album\n<span class=\"hljs-keyword\">JOIN</span>\n    Artist <span class=\"hljs-keyword\">ON</span>\n        Album.ArtistId <span class=\"hljs-operator\">=</span> Artist.ArtistId\n<span class=\"hljs-keyword\">WHERE</span>\n    Album.Title <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;%live%&#x27;</span>;\n</code></pre><p>As you can see, once you set up the JOIN and how you want to join the tables together, you can start filtering your results based on either table. The first query we asked for only Nirvana&#39;s albums, the second is just albums named <code>IV</code>, and the third we&#39;re asking for any album that <code>live</code> in it.</p>\n<h2>Joining more than two tables</h2>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    Artist.Name, Album.Title, Track.Name\n<span class=\"hljs-keyword\">FROM</span>\n    Album\n<span class=\"hljs-keyword\">JOIN</span>\n    Artist <span class=\"hljs-keyword\">ON</span>\n        Album.ArtistId <span class=\"hljs-operator\">=</span> Artist.ArtistId\n<span class=\"hljs-keyword\">JOIN</span>\n    Track <span class=\"hljs-keyword\">ON</span>\n        Track.AlbumId <span class=\"hljs-operator\">=</span> Album.AlbumId\n<span class=\"hljs-keyword\">WHERE</span>\n    Album.Title <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;IV&#x27;</span>;\n</code></pre><p>As you can see, you can just keep joining tables as long you have ways to join the table.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n    Artist.Name, Album.Title, Track.Name, Genre.Name\n<span class=\"hljs-keyword\">FROM</span>\n    Album\n<span class=\"hljs-keyword\">JOIN</span>\n    Artist <span class=\"hljs-keyword\">ON</span>\n        Album.ArtistId <span class=\"hljs-operator\">=</span> Artist.ArtistId\n<span class=\"hljs-keyword\">JOIN</span>\n    Track <span class=\"hljs-keyword\">ON</span>\n        Track.AlbumId <span class=\"hljs-operator\">=</span> Album.AlbumId\n<span class=\"hljs-keyword\">JOIN</span>\n    Genre <span class=\"hljs-keyword\">ON</span>\n        Track.GenreId <span class=\"hljs-operator\">=</span> Genre.GenreId\n<span class=\"hljs-keyword\">WHERE</span>\n    Artist.Name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Foo Fighters&#x27;</span>;\n</code></pre><p>You can just keep joining as you need to.</p>\n","markdown":"So far we've done a one-to-one matching of records. We've used a record in a database to represent one item: one band member, band, etc.\n\nNow we're going to get into records that can relate to each other. Let's think about albums. An album has multiple tracks. That **has** word is key here. It means there is a relationship. A single album has many tracks. This is a one-to-many relationship – one album has multiple tracks. Those tracks belong to that album. A track does not belong to multiple albums (in theory you could model this differently but let's say we choose to model it this way.)\n\nA band member can belong to multiple bands, and a band has multiple members. Dave Grohl has been in Nirvana, Foo Fighters, and Them Crooked Vultures. This kind of relationship is called many-to-many. Recipes and ingredients would be another good example of this. A recipe has many ingredients, and an ingredient can belong to many recipes.\n\nThere can also exist one-to-one relationships but in general, you would just make those the same record altogether. You could split up the type and title into two tables, but why would you? Then you have a data sync problem. What if a band renames themselves? Ex: On a Friday → Radiohead, Prince → The Artist Formerly Known as Prince, The Quarrymen → The Beatles. Anyone who has ever tried to manually keep data in sync in two+ places knows eventually you will have issues.\n\nLuckily we can use relational data to have one table of bands and one table of albums.\n\n```sql\nSELECT * FROM Album LIMIT 5;\n```\n\nNotice that we're just getting ArtistId (a number) instead of the actual name of the band. That's not what we want, we want to see the name of the album and the name of the band. Enter JOINs. This allows us to join two tables based on common data. Let's see how to do that.\n\n```sql\nSELECT\n    Artist.Name, Album.Title\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nLIMIT 5;\n```\n\n> Once we start getting into longer queries (especially when in code) I start spacing it out using new lines to make it easier to read. Makes it easier to understand at a glance.\n\nWe JOIN'd the Artist table to the Album table based on them sharing a common ArtistId. Pretty cool, right? Let's look at a few more tricks here.\n\n## Table Aliases\n\n```sql\nSELECT\n    b.Name, a.Title\nFROM\n    Album a\nJOIN\n    Artist b ON\n        a.ArtistId = b.ArtistId\nLIMIT 5;\n```\n\nYou can give tables aliases so they're easier to refer to. Some of the table names can get quite long so this can make it more readable. In this case, I'd argue that the single-letter variable names make it _less_ readable, that's up to you.\n\n## You can use WHERE!\n\n```sql\nSELECT\n    Artist.Name, Album.Title\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nWHERE\n    Artist.Name = 'Nirvana';\n\nSELECT\n    Artist.Name, Album.Title\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nWHERE\n    Album.Title = 'IV';\n\nSELECT\n    Artist.Name, Album.Title\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nWHERE\n    Album.Title LIKE '%live%';\n```\n\nAs you can see, once you set up the JOIN and how you want to join the tables together, you can start filtering your results based on either table. The first query we asked for only Nirvana's albums, the second is just albums named `IV`, and the third we're asking for any album that `live` in it.\n\n## Joining more than two tables\n\n```sql\nSELECT\n    Artist.Name, Album.Title, Track.Name\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nJOIN\n    Track ON\n        Track.AlbumId = Album.AlbumId\nWHERE\n    Album.Title = 'IV';\n```\n\nAs you can see, you can just keep joining tables as long you have ways to join the table.\n\n```sql\nSELECT\n    Artist.Name, Album.Title, Track.Name, Genre.Name\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nJOIN\n    Track ON\n        Track.AlbumId = Album.AlbumId\nJOIN\n    Genre ON\n        Track.GenreId = Genre.GenreId\nWHERE\n    Artist.Name = 'Foo Fighters';\n```\n\nYou can just keep joining as you need to.\n","slug":"relational-data","title":"Relational Data","section":"Intermediate SQL","icon":"table","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/04-intermediate-sql/A-relational-data.md","nextSlug":"/lessons/intermediate-sql/other-types-of-joins","prevSlug":"/lessons/basic-sql/tables"}},"__N_SSG":true}