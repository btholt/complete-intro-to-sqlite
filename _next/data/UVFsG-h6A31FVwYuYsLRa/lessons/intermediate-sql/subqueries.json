{"pageProps":{"post":{"attributes":{},"html":"<p>Okay, what if you want to find all customer invoices from a certain email address? Using joins, we could accomplish</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n <span class=\"hljs-operator\">*</span>\n<span class=\"hljs-keyword\">FROM</span>\n  Invoice i\n\n<span class=\"hljs-keyword\">JOIN</span>\n  Customer c\n<span class=\"hljs-keyword\">ON</span>\n  c.CustomerId <span class=\"hljs-operator\">=</span> i.CustomerId\n\n<span class=\"hljs-keyword\">WHERE</span>\n  c.Email <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;hholy@gmail.com&#x27;</span>;\n</code></pre><p>This totally works and if you like this, roll with it. No issues here. However I&#39;m going to show you a second way (mostly to demonstrate subqueries!)</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  <span class=\"hljs-operator\">*</span>\n<span class=\"hljs-keyword\">FROM</span>\n  Invoice\n<span class=\"hljs-keyword\">WHERE</span>\n  CustomerId <span class=\"hljs-operator\">=</span> (\n    <span class=\"hljs-keyword\">SELECT</span> CustomerId <span class=\"hljs-keyword\">FROM</span> Customer <span class=\"hljs-keyword\">WHERE</span> Email<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;hholy@gmail.com&#x27;</span>\n  );\n</code></pre><p>If you put parens in, you can do a subquery. This query is run first and its results can be fed into the parent query. In this case, we use a subquery to find the ID of the email. In this case, for a one-off query, the performance difference isn&#39;t important. If this was a thing run constantly in production and it was slow, I&#39;d analyze the performance of both and pick the better one given our data and indexes (stuff we&#39;ll talk about later.)</p>\n<p>In thise case you can use JOINs to work around using subqueries but it&#39;s not always possible. It&#39;s a good little tool in your SQL tool belt to have.</p>\n","markdown":"Okay, what if you want to find all customer invoices from a certain email address? Using joins, we could accomplish\n\n```sql\nSELECT\n *\nFROM\n  Invoice i\n\nJOIN\n  Customer c\nON\n  c.CustomerId = i.CustomerId\n\nWHERE\n  c.Email = 'hholy@gmail.com';\n```\n\nThis totally works and if you like this, roll with it. No issues here. However I'm going to show you a second way (mostly to demonstrate subqueries!)\n\n```sql\nSELECT\n  *\nFROM\n  Invoice\nWHERE\n  CustomerId = (\n    SELECT CustomerId FROM Customer WHERE Email='hholy@gmail.com'\n  );\n```\n\nIf you put parens in, you can do a subquery. This query is run first and its results can be fed into the parent query. In this case, we use a subquery to find the ID of the email. In this case, for a one-off query, the performance difference isn't important. If this was a thing run constantly in production and it was slow, I'd analyze the performance of both and pick the better one given our data and indexes (stuff we'll talk about later.)\n\nIn thise case you can use JOINs to work around using subqueries but it's not always possible. It's a good little tool in your SQL tool belt to have.\n","slug":"subqueries","title":"Subqueries","section":"Intermediate SQL","icon":"table","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/04-intermediate-sql/E-subqueries.md","nextSlug":"/lessons/build-a-project-with-nodejs-and-sqlite/the-example-app","prevSlug":"/lessons/intermediate-sql/aggregation"}},"__N_SSG":true}