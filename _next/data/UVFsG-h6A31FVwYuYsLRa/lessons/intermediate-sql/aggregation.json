{"pageProps":{"post":{"attributes":{"description":""},"html":"<p>Occasionally you need to query for macro statistics about your tables, not just query for individual rows.</p>\n<p>Let&#39;s use what we&#39;ve already used before, <code>COUNT</code>. What if we want to know how many tracks we have overall in our track table?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">FROM</span> Track;\n</code></pre><p><code>COUNT</code> is an aggregation function. We give the <code>*</code> is saying &quot;count everything and don&#39;t remove nulls or duplicates of any variety&quot;.</p>\n<p>What if we wanted to count how many distinct <code>genre</code>s of tracks we have in the Track table?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-keyword\">DISTINCT</span> GenreId) <span class=\"hljs-keyword\">FROM</span> Track;\n</code></pre><p>This is going to tell how many different <code>type</code>s we have in the ingredients table. Keep in mind the query to see <em>what</em> the distinct ingredients are.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> GenreId <span class=\"hljs-keyword\">FROM</span> Track;\n</code></pre><p>The first query gives you the number, the count of many distinct things in the list. The second query gives you what those distinct things are with no indication of how many of each there are. There could be 1 fruit and 10,000 vegetables and you&#39;d not indicate that.</p>\n<p>Okay, so you want to see both at the same time? Let&#39;s see that.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  GenreId, <span class=\"hljs-built_in\">COUNT</span>(GenreId)\n<span class=\"hljs-keyword\">FROM</span>\n  Track\n<span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span>\n  GenreId;\n</code></pre><p>This is combining both of what we saw plus a new thing, <code>GROUP BY</code>. This allows us to specify what things we want to aggregate together: the type. Keep in mind if you want to SELECT for something with a GROUP BY clause, you do need to put them in the GROUP BY clause.</p>\n<p>Now what if we want to include the actual genre names?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  Track.GenreId, Genre.Name, <span class=\"hljs-built_in\">COUNT</span>(Track.GenreId)\n<span class=\"hljs-keyword\">FROM</span>\n  Track\n<span class=\"hljs-keyword\">JOIN</span>\n    Genre\n<span class=\"hljs-keyword\">ON</span>\n    Genre.GenreId <span class=\"hljs-operator\">=</span> Track.GenreId\n<span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span>\n  Track.GenreId; <span class=\"hljs-comment\">-- you can also have Genre.GenreId here, no difference</span>\n</code></pre><p>This one can be a bit of a mind trip. Remember the aggregation happens at the end. So after all your selects happen, then on the row set, it goes and runs the aggregation function here using the GROUP BY. So we get a bunch of rows with their Genre.Name attached, and then we count those up.</p>\n<p>What if we wanted to find the biggest or smallest TrackId with each genre? (Doesn&#39;t seem that useful but I&#39;ll still show you how.)</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  Track.GenreId, Genre.Name, <span class=\"hljs-built_in\">MAX</span>(Track.TrackId) <span class=\"hljs-comment\">-- MIN(Track.TrackId)</span>\n<span class=\"hljs-keyword\">FROM</span>\n  Track\n<span class=\"hljs-keyword\">JOIN</span>\n    Genre\n<span class=\"hljs-keyword\">ON</span>\n    Genre.GenreId <span class=\"hljs-operator\">=</span> Track.GenreId\n<span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span>\n  Track.GenreId;\n</code></pre><h2>HAVING</h2>\n<p>What if you only want genres that have more than 300 tracks?</p>\n<blockquote>\n<p>The following query does not work.</p>\n</blockquote>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  Track.GenreId, Genre.Name, <span class=\"hljs-built_in\">COUNT</span>(Track.GenreId)\n<span class=\"hljs-keyword\">FROM</span>\n  Track\n<span class=\"hljs-keyword\">JOIN</span>\n    Genre\n<span class=\"hljs-keyword\">ON</span>\n    Genre.GenreId <span class=\"hljs-operator\">=</span> Track.GenreId\n<span class=\"hljs-keyword\">WHERE</span>\n    <span class=\"hljs-built_in\">COUNT</span>(Track.GenreId) <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">500</span>\n<span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span>\n  Track.GenreId;\n</code></pre><p>You can&#39;t use WHERE because that applies to the initial result set. You could filter out all rock songs or only select tracks with a certain length. But you can&#39;t filter based on the aggregated values because that happens after WHERE happens. This is why HAVING is useful.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  Track.GenreId, Genre.Name, <span class=\"hljs-built_in\">COUNT</span>(Track.GenreId)\n<span class=\"hljs-keyword\">FROM</span>\n  Track\n<span class=\"hljs-keyword\">JOIN</span>\n    Genre\n<span class=\"hljs-keyword\">ON</span>\n    Genre.GenreId <span class=\"hljs-operator\">=</span> Track.GenreId\n<span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span>\n  Track.GenreId\n<span class=\"hljs-keyword\">HAVING</span>\n    <span class=\"hljs-built_in\">COUNT</span>(Track.GenreId) <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">300</span>;\n</code></pre><p>Using HAVING we can filter on the aggregated set. Keep that mind if you ever need to do that.</p>\n","markdown":"\nOccasionally you need to query for macro statistics about your tables, not just query for individual rows.\n\nLet's use what we've already used before, `COUNT`. What if we want to know how many tracks we have overall in our track table?\n\n```sql\nSELECT COUNT(*) FROM Track;\n```\n\n`COUNT` is an aggregation function. We give the `*` is saying \"count everything and don't remove nulls or duplicates of any variety\".\n\nWhat if we wanted to count how many distinct `genre`s of tracks we have in the Track table?\n\n```sql\nSELECT COUNT(DISTINCT GenreId) FROM Track;\n```\n\nThis is going to tell how many different `type`s we have in the ingredients table. Keep in mind the query to see _what_ the distinct ingredients are.\n\n```sql\nSELECT DISTINCT GenreId FROM Track;\n```\n\nThe first query gives you the number, the count of many distinct things in the list. The second query gives you what those distinct things are with no indication of how many of each there are. There could be 1 fruit and 10,000 vegetables and you'd not indicate that.\n\nOkay, so you want to see both at the same time? Let's see that.\n\n```sql\nSELECT\n  GenreId, COUNT(GenreId)\nFROM\n  Track\nGROUP BY\n  GenreId;\n```\n\nThis is combining both of what we saw plus a new thing, `GROUP BY`. This allows us to specify what things we want to aggregate together: the type. Keep in mind if you want to SELECT for something with a GROUP BY clause, you do need to put them in the GROUP BY clause.\n\nNow what if we want to include the actual genre names?\n\n```sql\nSELECT\n  Track.GenreId, Genre.Name, COUNT(Track.GenreId)\nFROM\n  Track\nJOIN\n    Genre\nON\n    Genre.GenreId = Track.GenreId\nGROUP BY\n  Track.GenreId; -- you can also have Genre.GenreId here, no difference\n```\n\nThis one can be a bit of a mind trip. Remember the aggregation happens at the end. So after all your selects happen, then on the row set, it goes and runs the aggregation function here using the GROUP BY. So we get a bunch of rows with their Genre.Name attached, and then we count those up.\n\nWhat if we wanted to find the biggest or smallest TrackId with each genre? (Doesn't seem that useful but I'll still show you how.)\n\n```sql\nSELECT\n  Track.GenreId, Genre.Name, MAX(Track.TrackId) -- MIN(Track.TrackId)\nFROM\n  Track\nJOIN\n    Genre\nON\n    Genre.GenreId = Track.GenreId\nGROUP BY\n  Track.GenreId;\n```\n\n## HAVING\n\nWhat if you only want genres that have more than 300 tracks?\n\n> The following query does not work.\n\n```sql\nSELECT\n  Track.GenreId, Genre.Name, COUNT(Track.GenreId)\nFROM\n  Track\nJOIN\n    Genre\nON\n    Genre.GenreId = Track.GenreId\nWHERE\n    COUNT(Track.GenreId) > 500\nGROUP BY\n  Track.GenreId;\n```\n\nYou can't use WHERE because that applies to the initial result set. You could filter out all rock songs or only select tracks with a certain length. But you can't filter based on the aggregated values because that happens after WHERE happens. This is why HAVING is useful.\n\n```sql\nSELECT\n  Track.GenreId, Genre.Name, COUNT(Track.GenreId)\nFROM\n  Track\nJOIN\n    Genre\nON\n    Genre.GenreId = Track.GenreId\nGROUP BY\n  Track.GenreId\nHAVING\n    COUNT(Track.GenreId) > 300;\n```\n\nUsing HAVING we can filter on the aggregated set. Keep that mind if you ever need to do that.\n","slug":"aggregation","title":"Aggregation","section":"Intermediate SQL","icon":"table","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/04-intermediate-sql/D-aggregation.md","nextSlug":"/lessons/intermediate-sql/subqueries","prevSlug":"/lessons/intermediate-sql/foreign-keys"}},"__N_SSG":true}