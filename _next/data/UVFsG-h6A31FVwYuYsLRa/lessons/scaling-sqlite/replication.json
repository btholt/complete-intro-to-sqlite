{"pageProps":{"post":{"attributes":{},"html":"<p>Okay, so we&#39;ve been building locally with SQLite and most people end here. Now that they&#39;ve built their app as big as they want to locally, they&#39;ll move to Postgres or MySQL. And frankly this is a totally acceptable thing to do if you are so inclined. I&#39;ve been using Postgres myself for years like this. However I think this is sort of a vim thing: I&#39;ve used Postgres for so many years and know it so well that I already know well how to use it (like vim users, who have already suffered through the hard part of learning.)</p>\n<p>In any case, you no longer have to switch off of SQLite ever if you are so inclined. There is now something called <a href=\"https://github.com/superfly/litefs\">litefs</a>. Litefs is a tool that simulates a virtual filesystem and then replicates it across machines. In otherwords, it tricks SQLite into thinking it&#39;s just reading and writing to a file and underneath it is replicating it out to other replicas.</p>\n<p>You end up with a primary node that you can read and write to and secondary nodes that you can write to. It&#39;s a smart, elegant system that has some great upside in how simple it is to manage and how simple SQLite is, and how fast it is since your database is running on the same node as your app so reads are local-speed instead of having to go over a network.</p>\n<p>The downside is that your secondary nodes do have a bit of lag in receiving updates. Normally it&#39;s fast enough for most apps that this eventual consistency isn&#39;t a problem (it&#39;s usually like 200ms, depending on network speed and other things.) However if you&#39;re doing things were strong consistency is essential, this probably not your solution.</p>\n<p>You&#39;re also using SQLite, for all the good and bad that means. That are lots of advantages that other databases have, so just keep in that mind.</p>\n<p>Okay, so, let&#39;s adapt our little project and make it work in a distributed fashion. <a href=\"https://github.com/btholt/sqlite-app-litefs\">Clone this repo</a> and let&#39;s explore what&#39;s going on here.</p>\n<ul>\n<li>This already pre-completed so no code needed to write here.</li>\n<li>This is a <a href=\"https://docs.docker.com/compose/\">Docker Compose project</a>. This means it will orchestrate multiple containers together to get this project. If you want to learn more, <a href=\"https://frontendmasters.com/courses/complete-intro-containers-v2/docker-compose/\">watch my segment on it on Frontend Masters</a>.</li>\n<li>In our case we&#39;ll have an NGINX container that will act as ingress for traffic and also round-robin the connections to our primary and secondary nodes.</li>\n<li>We have two types of app nodes. The primary node (which there were only ever be one) has the SQLite node that you can write to. The secondary node(s) will have read only replica copies. You could have many of these but for simplicity&#39;s sake I hard coded it to be one copy</li>\n<li><a href=\"https://github.com/btholt/sqlite-app-litefs/blob/main/invoice.js#L3\">Notice</a> that I&#39;m connecting to <code>/litefs/data.db</code>. This is the virtual filesystem. As long as we&#39;re doing that, we&#39;ll be connecting to the distributed SQLite database.</li>\n<li>Feel free to look at the Dockerfile, docker-compose.yml and etc/litefs.yml. Those are probably the most interesting config files.</li>\n</ul>\n<p>Let&#39;s run it. Run</p>\n<pre><code class=\"hljs language-bash\">docker compose up --build\n</code></pre><p>You should be able to see the app running at <a href=\"http://localhost:8080\">http://localhost:8080</a>.</p>\n<blockquote>\n<p>ðŸš¨ If you see a weird SQLITE_ERROR, errno 1 error, delete you node_modules on your local computer and re-run Docker so that it builds the container again.</p>\n</blockquote>\n<p>Let&#39;s try connecting to the nodes themselves.</p>\n<pre><code class=\"hljs language-bash\">docker <span class=\"hljs-built_in\">exec</span> -it sqlite-project-litefs-primary-1 sqlite3 /litefs/data.db\ndocker <span class=\"hljs-built_in\">exec</span> -it sqlite-project-litefs-replica1-1 sqlite3 /litefs/data.db\n</code></pre><p>Pretty cool right? We&#39;re now working with a distributed SQLite database!!</p>\n","markdown":"Okay, so we've been building locally with SQLite and most people end here. Now that they've built their app as big as they want to locally, they'll move to Postgres or MySQL. And frankly this is a totally acceptable thing to do if you are so inclined. I've been using Postgres myself for years like this. However I think this is sort of a vim thing: I've used Postgres for so many years and know it so well that I already know well how to use it (like vim users, who have already suffered through the hard part of learning.)\n\nIn any case, you no longer have to switch off of SQLite ever if you are so inclined. There is now something called [litefs][litefs]. Litefs is a tool that simulates a virtual filesystem and then replicates it across machines. In otherwords, it tricks SQLite into thinking it's just reading and writing to a file and underneath it is replicating it out to other replicas.\n\nYou end up with a primary node that you can read and write to and secondary nodes that you can write to. It's a smart, elegant system that has some great upside in how simple it is to manage and how simple SQLite is, and how fast it is since your database is running on the same node as your app so reads are local-speed instead of having to go over a network.\n\nThe downside is that your secondary nodes do have a bit of lag in receiving updates. Normally it's fast enough for most apps that this eventual consistency isn't a problem (it's usually like 200ms, depending on network speed and other things.) However if you're doing things were strong consistency is essential, this probably not your solution.\n\nYou're also using SQLite, for all the good and bad that means. That are lots of advantages that other databases have, so just keep in that mind.\n\nOkay, so, let's adapt our little project and make it work in a distributed fashion. [Clone this repo][repo] and let's explore what's going on here.\n\n- This already pre-completed so no code needed to write here.\n- This is a [Docker Compose project][compose]. This means it will orchestrate multiple containers together to get this project. If you want to learn more, [watch my segment on it on Frontend Masters][compose-video].\n- In our case we'll have an NGINX container that will act as ingress for traffic and also round-robin the connections to our primary and secondary nodes.\n- We have two types of app nodes. The primary node (which there were only ever be one) has the SQLite node that you can write to. The secondary node(s) will have read only replica copies. You could have many of these but for simplicity's sake I hard coded it to be one copy\n- [Notice][db-connection] that I'm connecting to `/litefs/data.db`. This is the virtual filesystem. As long as we're doing that, we'll be connecting to the distributed SQLite database.\n- Feel free to look at the Dockerfile, docker-compose.yml and etc/litefs.yml. Those are probably the most interesting config files.\n\nLet's run it. Run\n\n```bash\ndocker compose up --build\n```\n\nYou should be able to see the app running at [http://localhost:8080](http://localhost:8080).\n\n> ðŸš¨ If you see a weird SQLITE_ERROR, errno 1 error, delete you node_modules on your local computer and re-run Docker so that it builds the container again.\n\nLet's try connecting to the nodes themselves.\n\n```bash\ndocker exec -it sqlite-project-litefs-primary-1 sqlite3 /litefs/data.db\ndocker exec -it sqlite-project-litefs-replica1-1 sqlite3 /litefs/data.db\n```\n\nPretty cool right? We're now working with a distributed SQLite database!!\n\n[litefs]: https://github.com/superfly/litefs\n[repo]: https://github.com/btholt/sqlite-app-litefs\n[db-connection]: https://github.com/btholt/sqlite-app-litefs/blob/main/invoice.js#L3\n[compose]: https://docs.docker.com/compose/\n[compose-video]: https://frontendmasters.com/courses/complete-intro-containers-v2/docker-compose/\n","slug":"replication","title":"Replication","section":"Scaling SQLite","icon":"server","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/09-scaling-sqlite/B-replication.md","nextSlug":"/lessons/scaling-sqlite/libsql","prevSlug":"/lessons/scaling-sqlite/backups"}},"__N_SSG":true}