{"pageProps":{"post":{"attributes":{"title":"SELECT"},"html":"<p>I like to learn SQL by doing rather than some contrived explanation of how grammar is broken down and blah blah blah. I like putting fingers on keyboards and seeing what happens when we do things. Once we start to experience what SQL can do for us then we can get a bit more fine-grained in terms of what is doing what and why.</p>\n<blockquote>\n<p>Note, this is meant to be a very quick intro to general SQL. I&#39;ve taught <a href=\"https://frontendmasters.com/courses/sql/\">the Complete Intro to SQL</a> before and it&#39;s more in-depth. This class uses Postgres but 95% of the grammar applies to both. I&#39;ll highlight where there&#39;s differences.</p>\n</blockquote>\n<h2>SELECT</h2>\n<p>You should already have a database session open and have Chinook loaded. If not, look back at the previous lesson on how to do that.</p>\n<p>SELECT is the name of the &quot;command&quot; part of the query. It&#39;s what the command is going to do. In our case, we&#39;re going to be reading from the database which is a SELECT command.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Artist;\n</code></pre><blockquote>\n<p>Capitalization of SELECT and FROM isn&#39;t important. I usually do it out of habit because <em>everyone</em> used to do it that way. It&#39;s not as common now and you&#39;ll see me do both.</p>\n</blockquote>\n<p>This will return about 275 rows from the database. We asked for <em>every</em> single artist in the Artist table and we got it! The <code>*</code> just means that we wanted every single bit of info available for every artist. If we only wanted <em>some</em> of the info, we could ask for that like this.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> name <span class=\"hljs-keyword\">from</span> Artist;\n</code></pre><p>Notice the number is gone (which was the <code>ArtistId</code>) and we just have the name for each band. We could also ask for both like this</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> name, ArtistId <span class=\"hljs-keyword\">from</span> Artist;\n</code></pre><p>Notice the columns came back in the order you asked for them too.</p>\n<blockquote>\n<p>If you need to get the name of columns, <code>.schema &lt;TABLE_NAME&gt;</code> is helpful.</p>\n</blockquote>\n<h2>WHERE</h2>\n<p>In this case, we&#39;re querying all rows without any filtering whatsoever. Sometimes this is useful but normally you have an idea of some subset of rows you want. Let&#39;s say we wanted to get the ID of one of my favorite bands, The Postal Service. How would we do that?</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> ArtistID <span class=\"hljs-keyword\">FROM</span> Artist <span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;The Postal Service&#x27;</span>;\n</code></pre><blockquote>\n<p>Very important you use single quotes here. Single quotes mean a value or string literal. Double quotes in SQL refer to he name of columns and so putting double quotes would not be valid SQL.</p>\n</blockquote>\n<p>This will just return <code>174</code> because that&#39;s all we asked for. Likewise, we could do</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> name <span class=\"hljs-keyword\">FROM</span> Artist <span class=\"hljs-keyword\">WHERE</span> ArtistId <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">174</span>;\n</code></pre><p>This one doesn&#39;t need quotes because it&#39;s the literal number 174.</p>\n<h2>LIKE</h2>\n<p>Let&#39;s say you didn&#39;t know if The Postal Service was listed under &quot;<strong>The</strong> Postal Service&quot; or just &quot;Postal Service&quot;. This is where LIKE can help.</p>\n<blockquote>\n<p>SQLite does not have ILIKE, just LIKE. LIKE is case insensitive.</p>\n</blockquote>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> ArtistID <span class=\"hljs-keyword\">FROM</span> Artist <span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;%Postal Service&#x27;</span>;\n</code></pre><p>This will match &quot;The Postal Service&quot;, &quot;Postal Service&quot;, &quot;Definitely Postal Service&quot; and anything that has text before &quot;Postal Service&quot;. The <code>%</code> means &quot;give anything that matches 0 to many characters before this&quot;.</p>\n<p>You can use multiple too. Let&#39;s say we wanted to know every band that had &quot;Orchestra&quot; in the name. We can do that with</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> name <span class=\"hljs-keyword\">FROM</span> Artist <span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;%orchestra%&#x27;</span>;\n</code></pre><p>Pretty cool, right?</p>\n<p>There are more comparator operators that you can discover for yourself as well</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Artist <span class=\"hljs-keyword\">WHERE</span> ArtistId <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">10</span>;\n</code></pre><h2>LIMIT and OFFSET</h2>\n<p>Sometimes you just want a few responses. I do this a lot to just see what&#39;s in a table.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Artist LIMIT <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Artist LIMIT <span class=\"hljs-number\">5</span> <span class=\"hljs-keyword\">OFFSET</span> <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Artist LIMIT <span class=\"hljs-number\">5</span> <span class=\"hljs-keyword\">OFFSET</span> <span class=\"hljs-number\">10</span>;\n</code></pre><p>This will allow you to page through results as well.</p>\n<h2>ORDER BY</h2>\n<p>Frequently you will want to change how things are ordered as well.</p>\n<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Artist <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> name LIMIT <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Artist <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> name <span class=\"hljs-keyword\">ASC</span> LIMIT <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">-- Same as above query. ASC is implied if left out.</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> Artist <span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> name <span class=\"hljs-keyword\">DESC</span> LIMIT <span class=\"hljs-number\">5</span>;\n</code></pre>","markdown":"\nI like to learn SQL by doing rather than some contrived explanation of how grammar is broken down and blah blah blah. I like putting fingers on keyboards and seeing what happens when we do things. Once we start to experience what SQL can do for us then we can get a bit more fine-grained in terms of what is doing what and why.\n\n> Note, this is meant to be a very quick intro to general SQL. I've taught [the Complete Intro to SQL][sql] before and it's more in-depth. This class uses Postgres but 95% of the grammar applies to both. I'll highlight where there's differences.\n\n## SELECT\n\nYou should already have a database session open and have Chinook loaded. If not, look back at the previous lesson on how to do that.\n\nSELECT is the name of the \"command\" part of the query. It's what the command is going to do. In our case, we're going to be reading from the database which is a SELECT command.\n\n```sql\nSELECT * FROM Artist;\n```\n\n> Capitalization of SELECT and FROM isn't important. I usually do it out of habit because _everyone_ used to do it that way. It's not as common now and you'll see me do both.\n\nThis will return about 275 rows from the database. We asked for _every_ single artist in the Artist table and we got it! The `*` just means that we wanted every single bit of info available for every artist. If we only wanted _some_ of the info, we could ask for that like this.\n\n```sql\nSELECT name from Artist;\n```\n\nNotice the number is gone (which was the `ArtistId`) and we just have the name for each band. We could also ask for both like this\n\n```sql\nSELECT name, ArtistId from Artist;\n```\n\nNotice the columns came back in the order you asked for them too.\n\n> If you need to get the name of columns, `.schema <TABLE_NAME>` is helpful.\n\n## WHERE\n\nIn this case, we're querying all rows without any filtering whatsoever. Sometimes this is useful but normally you have an idea of some subset of rows you want. Let's say we wanted to get the ID of one of my favorite bands, The Postal Service. How would we do that?\n\n```sql\nSELECT ArtistID FROM Artist WHERE name = 'The Postal Service';\n```\n\n> Very important you use single quotes here. Single quotes mean a value or string literal. Double quotes in SQL refer to he name of columns and so putting double quotes would not be valid SQL.\n\nThis will just return `174` because that's all we asked for. Likewise, we could do\n\n```sql\nSELECT name FROM Artist WHERE ArtistId = 174;\n```\n\nThis one doesn't need quotes because it's the literal number 174.\n\n## LIKE\n\nLet's say you didn't know if The Postal Service was listed under \"**The** Postal Service\" or just \"Postal Service\". This is where LIKE can help.\n\n> SQLite does not have ILIKE, just LIKE. LIKE is case insensitive.\n\n```sql\nSELECT ArtistID FROM Artist WHERE name LIKE '%Postal Service';\n```\n\nThis will match \"The Postal Service\", \"Postal Service\", \"Definitely Postal Service\" and anything that has text before \"Postal Service\". The `%` means \"give anything that matches 0 to many characters before this\".\n\nYou can use multiple too. Let's say we wanted to know every band that had \"Orchestra\" in the name. We can do that with\n\n```sql\nSELECT name FROM Artist WHERE name LIKE '%orchestra%';\n```\n\nPretty cool, right?\n\nThere are more comparator operators that you can discover for yourself as well\n\n```sql\nSELECT * FROM Artist WHERE ArtistId <= 10;\n```\n\n## LIMIT and OFFSET\n\nSometimes you just want a few responses. I do this a lot to just see what's in a table.\n\n```sql\nSELECT * FROM Artist LIMIT 5;\nSELECT * FROM Artist LIMIT 5 OFFSET 5;\nSELECT * FROM Artist LIMIT 5 OFFSET 10;\n```\n\nThis will allow you to page through results as well.\n\n## ORDER BY\n\nFrequently you will want to change how things are ordered as well.\n\n```SQL\nSELECT * FROM Artist ORDER BY name LIMIT 5;\nSELECT * FROM Artist ORDER BY name ASC LIMIT 5; -- Same as above query. ASC is implied if left out.\nSELECT * FROM Artist ORDER BY name DESC LIMIT 5;\n```\n\n[sql]: https://frontendmasters.com/courses/sql/\n","slug":"select","title":"SELECT","section":"Basic SQL","icon":"database","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/03-basic-sql/A-select.md","nextSlug":"/lessons/basic-sql/insert","prevSlug":"/lessons/running-sqlite/getting-started"}},"__N_SSG":true}