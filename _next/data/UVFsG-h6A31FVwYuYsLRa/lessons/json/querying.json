{"pageProps":{"post":{"attributes":{"title":"JSON"},"html":"<p>The JSON extension (<a href=\"https://sqlite.org/json1.html\">json1</a>) for SQLite is the most useful one to me, and one that I load nearly any time I do a project with SQLite. It is extremely useful for application development. It allows you to read and write arbitrary data. It allows you to treat SQLite essentially like a document-based database like MongoDB where you don&#39;t have to define your schema up front and can do so on the fly. It allows you to have arrays inside of rows instead of having to do one-to-many relations across tables. There are still reasons you&#39;d want to define schema and have relations across table, but this makes it easy for simple use cases where you don&#39;t need all the SQL rigor.</p>\n<p>Let&#39;s install it.</p>\n<pre><code class=\"hljs language-bash\">sqlpkg install sqlite/json1\nsqlpkg <span class=\"hljs-built_in\">which</span> sqlite/json1 <span class=\"hljs-comment\"># copy the out output of this</span>\n</code></pre><p>Now load your database and run this</p>\n<pre><code class=\"hljs language-sql\">.load <span class=\"hljs-operator\">/</span>Users<span class=\"hljs-operator\">/</span>my<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">user</span><span class=\"hljs-operator\">/</span>.sqlpkg<span class=\"hljs-operator\">/</span>sqlite<span class=\"hljs-operator\">/</span>json1<span class=\"hljs-operator\">/</span>json1.dylib\n\n<span class=\"hljs-keyword\">SELECT</span> json(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>);\n</code></pre><p>This should return back to you a JSON object of the string we passed in. As you can see, we can now operate with JSON inside of SQLite! Pretty cool, right? Let&#39;s try a few more.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- create an array</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">json_array</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n\n<span class=\"hljs-comment\">-- get the length of an array</span>\n<span class=\"hljs-keyword\">SELECT</span> json_array_length(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>, <span class=\"hljs-string\">&#x27;$.favorites&#x27;</span>);\n\n<span class=\"hljs-comment\">-- get the type of a field in an object</span>\n<span class=\"hljs-keyword\">SELECT</span> json_type(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>, <span class=\"hljs-string\">&#x27;$.username&#x27;</span>);\n\n<span class=\"hljs-comment\">-- construct a new object using pairs</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">json_object</span>(<span class=\"hljs-string\">&#x27;username&#x27;</span>, <span class=\"hljs-string\">&#x27;btholt&#x27;</span>, <span class=\"hljs-string\">&#x27;favorites&#x27;</span>, <span class=\"hljs-built_in\">json_array</span>(<span class=\"hljs-string\">&#x27;Daft Punk&#x27;</span>, <span class=\"hljs-string\">&#x27;Radiohead&#x27;</span>));\n</code></pre><p>These are a bunch of helper methods to help you interact with JSON objects in SQLite. Let&#39;s see how to manipulate it.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- add a new field</span>\n<span class=\"hljs-keyword\">SELECT</span> json_insert(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>, <span class=\"hljs-string\">&#x27;$.city&#x27;</span>, <span class=\"hljs-string\">&#x27;Sacramento&#x27;</span>);\n\n<span class=\"hljs-comment\">-- remove a field</span>\n<span class=\"hljs-keyword\">SELECT</span> json_remove(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>, <span class=\"hljs-string\">&#x27;$.favorites&#x27;</span>);\n\n<span class=\"hljs-comment\">-- update a field</span>\n<span class=\"hljs-keyword\">SELECT</span> json_replace(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>, <span class=\"hljs-string\">&#x27;$.username&#x27;</span>, <span class=\"hljs-string\">&#x27;holtbt&#x27;</span>);\n</code></pre><h2>-&gt; and -&gt;&gt;</h2>\n<p>SQLite provides two convenience operators that it copied from MySQL and Postgres to keep the syntaxes compatible. It allows you to extract specific values from JSON.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> json(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>) <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;username&#x27;</span>;\n<span class=\"hljs-keyword\">SELECT</span> json(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;name&quot;: { &quot;first&quot;: &quot;Brian&quot; }, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>) <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;name&#x27;</span>;\n<span class=\"hljs-keyword\">SELECT</span> json(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;name&quot;: { &quot;first&quot;: &quot;Brian&quot; }, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>) <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;name&#x27;</span> <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;first&#x27;</span>;\n</code></pre><p>Notice you can do multiple levels of extraction. Also notice that anything that coming back from with -&gt; operator has double quotes. That&#39;s because it&#39;s still treating it as JSON so that we can keep using -&gt; to dig further into objects. If we want it to return it as text or integer, we use -&gt;&gt;</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> json(<span class=\"hljs-string\">&#x27;{&quot;username&quot;: &quot;btholt&quot;, &quot;name&quot;: { &quot;first&quot;: &quot;Brian&quot; }, &quot;favorites&quot;:[&quot;Daft Punk&quot;, &quot;Radiohead&quot;]}&#x27;</span>) <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-string\">&#x27;name&#x27;</span> <span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">&gt;&gt;</span> <span class=\"hljs-string\">&#x27;first&#x27;</span>;\n</code></pre><p>-&gt;&gt; lets you get the actual value out and not JSON. Use it for your last extraction to acutally get the data out.</p>\n","markdown":"\nThe JSON extension ([json1][json1]) for SQLite is the most useful one to me, and one that I load nearly any time I do a project with SQLite. It is extremely useful for application development. It allows you to read and write arbitrary data. It allows you to treat SQLite essentially like a document-based database like MongoDB where you don't have to define your schema up front and can do so on the fly. It allows you to have arrays inside of rows instead of having to do one-to-many relations across tables. There are still reasons you'd want to define schema and have relations across table, but this makes it easy for simple use cases where you don't need all the SQL rigor.\n\nLet's install it.\n\n```bash\nsqlpkg install sqlite/json1\nsqlpkg which sqlite/json1 # copy the out output of this\n```\n\nNow load your database and run this\n\n```sql\n.load /Users/my-user/.sqlpkg/sqlite/json1/json1.dylib\n\nSELECT json('{\"username\": \"btholt\", \"favorites\":[\"Daft Punk\", \"Radiohead\"]}');\n```\n\nThis should return back to you a JSON object of the string we passed in. As you can see, we can now operate with JSON inside of SQLite! Pretty cool, right? Let's try a few more.\n\n```sql\n-- create an array\nSELECT json_array(1, 2, 3);\n\n-- get the length of an array\nSELECT json_array_length('{\"username\": \"btholt\", \"favorites\":[\"Daft Punk\", \"Radiohead\"]}', '$.favorites');\n\n-- get the type of a field in an object\nSELECT json_type('{\"username\": \"btholt\", \"favorites\":[\"Daft Punk\", \"Radiohead\"]}', '$.username');\n\n-- construct a new object using pairs\nSELECT json_object('username', 'btholt', 'favorites', json_array('Daft Punk', 'Radiohead'));\n```\n\nThese are a bunch of helper methods to help you interact with JSON objects in SQLite. Let's see how to manipulate it.\n\n```sql\n-- add a new field\nSELECT json_insert('{\"username\": \"btholt\", \"favorites\":[\"Daft Punk\", \"Radiohead\"]}', '$.city', 'Sacramento');\n\n-- remove a field\nSELECT json_remove('{\"username\": \"btholt\", \"favorites\":[\"Daft Punk\", \"Radiohead\"]}', '$.favorites');\n\n-- update a field\nSELECT json_replace('{\"username\": \"btholt\", \"favorites\":[\"Daft Punk\", \"Radiohead\"]}', '$.username', 'holtbt');\n```\n\n## -> and ->>\n\nSQLite provides two convenience operators that it copied from MySQL and Postgres to keep the syntaxes compatible. It allows you to extract specific values from JSON.\n\n```sql\nSELECT json('{\"username\": \"btholt\", \"favorites\":[\"Daft Punk\", \"Radiohead\"]}') -> 'username';\nSELECT json('{\"username\": \"btholt\", \"name\": { \"first\": \"Brian\" }, \"favorites\":[\"Daft Punk\", \"Radiohead\"]}') -> 'name';\nSELECT json('{\"username\": \"btholt\", \"name\": { \"first\": \"Brian\" }, \"favorites\":[\"Daft Punk\", \"Radiohead\"]}') -> 'name' -> 'first';\n```\n\nNotice you can do multiple levels of extraction. Also notice that anything that coming back from with -> operator has double quotes. That's because it's still treating it as JSON so that we can keep using -> to dig further into objects. If we want it to return it as text or integer, we use ->>\n\n```sql\nSELECT json('{\"username\": \"btholt\", \"name\": { \"first\": \"Brian\" }, \"favorites\":[\"Daft Punk\", \"Radiohead\"]}') -> 'name' ->> 'first';\n```\n\n->> lets you get the actual value out and not JSON. Use it for your last extraction to acutally get the data out.\n\n[json1]: https://sqlite.org/json1.html\n","slug":"querying","title":"JSON","section":"JSON","icon":"file-code","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/08-json/B-querying.md","nextSlug":"/lessons/json/jsonb","prevSlug":"/lessons/json/sqlite-extensions"}},"__N_SSG":true}