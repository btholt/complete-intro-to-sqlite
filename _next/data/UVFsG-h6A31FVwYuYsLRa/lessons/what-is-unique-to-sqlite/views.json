{"pageProps":{"post":{"attributes":{},"html":"<p>Views are not unique to SQLite but SQLite certainly has its own version of them.</p>\n<p>The idea of a view is that it is an abstract or virtual table that makes use of other data in the table. A really good use case for us is that getting a list of track names with artists and albums requires two joins right now. Any time we want to get that information, we have two to write a query with two joins.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span>\n  t.TrackId <span class=\"hljs-keyword\">as</span> id,\n  ar.Name <span class=\"hljs-keyword\">as</span> artist,\n  al.Title <span class=\"hljs-keyword\">as</span> album,\n  t.Name <span class=\"hljs-keyword\">as</span> track\n<span class=\"hljs-keyword\">FROM</span>\n  Track t\n\n<span class=\"hljs-keyword\">JOIN</span>\n  Album al\n<span class=\"hljs-keyword\">ON</span>\n  t.AlbumId <span class=\"hljs-operator\">=</span> al.AlbumId\n\n<span class=\"hljs-keyword\">JOIN</span>\n  Artist ar\n<span class=\"hljs-keyword\">ON</span>\n  ar.ArtistId <span class=\"hljs-operator\">=</span> al.ArtistId\n\nLIMIT <span class=\"hljs-number\">5</span>;\n</code></pre><p>This is a super usable set of data for us to list out all the tracks in a database. Now if it only wasn&#39;t so burdensome to query. Well, spoilers, it doesn&#39;t have to be. We can make a view that automatically does this for us and presents it as a pretty table.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span>\n  easy_tracks\n<span class=\"hljs-keyword\">AS</span>\n\n<span class=\"hljs-keyword\">SELECT</span>\n  t.TrackId <span class=\"hljs-keyword\">as</span> id,\n  ar.Name <span class=\"hljs-keyword\">as</span> artist,\n  al.Title <span class=\"hljs-keyword\">as</span> album,\n  t.Name <span class=\"hljs-keyword\">as</span> track\n<span class=\"hljs-keyword\">FROM</span>\n  Track t\n\n<span class=\"hljs-keyword\">JOIN</span>\n  Album al\n<span class=\"hljs-keyword\">ON</span>\n  t.AlbumId <span class=\"hljs-operator\">=</span> al.AlbumId\n\n<span class=\"hljs-keyword\">JOIN</span>\n  Artist ar\n<span class=\"hljs-keyword\">ON</span>\n  ar.ArtistId <span class=\"hljs-operator\">=</span> al.ArtistId;\n</code></pre><p>Now go ahead and <code>SELECT * FROM easy_tracks LIMIT 15;</code> to see what we did. Cool, right? We can even start doing things like joins to this table as well. If you find yourself constantly doing the same joins (like we have this whole course) views can your friend.</p>\n<blockquote>\n<p>SQLite does not do materialized views like Postgres. That is to say, we cannot tell SQLite &quot;run this query and store the results&quot; like you can in Postgres. SQLite is always querying the live data underneath. <a href=\"https://sql.holt.courses/lessons/views/materialized-views\">Click here to read more about materialized views</a>.</p>\n<p>SQLite also does not support inserting into views like other databases do.</p>\n</blockquote>\n","markdown":"Views are not unique to SQLite but SQLite certainly has its own version of them.\n\nThe idea of a view is that it is an abstract or virtual table that makes use of other data in the table. A really good use case for us is that getting a list of track names with artists and albums requires two joins right now. Any time we want to get that information, we have two to write a query with two joins.\n\n```sql\nSELECT\n  t.TrackId as id,\n  ar.Name as artist,\n  al.Title as album,\n  t.Name as track\nFROM\n  Track t\n\nJOIN\n  Album al\nON\n  t.AlbumId = al.AlbumId\n\nJOIN\n  Artist ar\nON\n  ar.ArtistId = al.ArtistId\n\nLIMIT 5;\n```\n\nThis is a super usable set of data for us to list out all the tracks in a database. Now if it only wasn't so burdensome to query. Well, spoilers, it doesn't have to be. We can make a view that automatically does this for us and presents it as a pretty table.\n\n```sql\nCREATE VIEW\n  easy_tracks\nAS\n\nSELECT\n  t.TrackId as id,\n  ar.Name as artist,\n  al.Title as album,\n  t.Name as track\nFROM\n  Track t\n\nJOIN\n  Album al\nON\n  t.AlbumId = al.AlbumId\n\nJOIN\n  Artist ar\nON\n  ar.ArtistId = al.ArtistId;\n```\n\nNow go ahead and `SELECT * FROM easy_tracks LIMIT 15;` to see what we did. Cool, right? We can even start doing things like joins to this table as well. If you find yourself constantly doing the same joins (like we have this whole course) views can your friend.\n\n> SQLite does not do materialized views like Postgres. That is to say, we cannot tell SQLite \"run this query and store the results\" like you can in Postgres. SQLite is always querying the live data underneath. [Click here to read more about materialized views][materialized].\n>\n> SQLite also does not support inserting into views like other databases do.\n\n[materialized]: https://sql.holt.courses/lessons/views/materialized-views\n","slug":"views","title":"Views","section":"What is Unique to SQLite","icon":"fingerprint","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/06-what-is-unique-to-sqlite/C-views.md","nextSlug":"/lessons/performance-and-search/explain","prevSlug":"/lessons/what-is-unique-to-sqlite/limits-of-sqlite"}},"__N_SSG":true}