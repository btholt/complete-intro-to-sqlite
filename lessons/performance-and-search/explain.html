<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><link rel="icon" type="image/x-icon" href="/images/favicon.ico"/><title>EXPLAIN – Complete Intro to SQLite</title><meta name="description" content="Learn how to build on SQLite with this quick and complete course with Brian Holt. SQLite is a powerful database that is easy to get started with and is a great tool for building both small and large applications."/><meta name="keywords" content="SQL,SQLite,Databases,Web Development,Node.js,JavaScript,Brian Holt,Frontend Masters"/><meta name="og:description" content="Learn how to build on SQLite with this quick and complete course with Brian Holt. SQLite is a powerful database that is easy to get started with and is a great tool for building both small and large applications."/><meta name="og:title" content="EXPLAIN – Complete Intro to SQLite"/><meta name="og:image" content="/images/social-share-cover.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="next-head-count" content="14"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/27123e75b7d47aaa.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27123e75b7d47aaa.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-4e7214a60fad8e88.js" defer=""></script><script src="/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/_next/static/chunks/main-be89c515900796e7.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a9fbd9f7480465a3.js" defer=""></script><script src="/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-f133ec3e69124099.js" defer=""></script><script src="/_next/static/UVFsG-h6A31FVwYuYsLRa/_buildManifest.js" defer=""></script><script src="/_next/static/UVFsG-h6A31FVwYuYsLRa/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to SQLite</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/workshops/sqlite/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Track <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;Black Dog&#x27;</span>;
PRAGMA index_list(<span class="hljs-string">&#x27;Track&#x27;</span>);
EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Track <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;Black Dog&#x27;</span>;
EXPLAIN QUERY PLAN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Track <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;Black Dog&#x27;</span>;
<span class="hljs-keyword">CREATE</span> INDEX idx_track_name <span class="hljs-keyword">ON</span> Track (Name);
EXPLAIN QUERY PLAN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Track <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;Black Dog&#x27;</span>;
PRAGMA index_list(<span class="hljs-string">&#x27;Track&#x27;</span>);
</code></pre><p>Generally speaking, SQLite is extremely fast even on large datasets. It does a great job of working with large amounts of data even on complicated queries. However occasionally it can use some help when you have heavy queries that you run frequently. Let&#39;s first understand how to look at queries using some fun features built into SQLite.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Track <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;Black Dog&#x27;</span>;
</code></pre><p>Let&#39;s say we are building an interface that frequently needs to look up tracks by their names. You&#39;d be running queries like this frequently. Right now our Track database has some 3,000 rows in it but imagine if you had Spotify&#39;s database of music. Spotify says it has over 100,000,000 tracks on it, so that query get very slow. Let&#39;s see a few of the ways that SQLite gives you to inspect your queries.</p>
<pre><code class="hljs language-sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Track <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;Black Dog&#x27;</span>;
</code></pre><pre><code>addr  opcode         p1    p2    p3    p4             p5  comment
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     17    0                    0   Start at 17
1     OpenRead       0     409   0     9              0   root=409 iDb=0; Track
2     Rewind         0     16    0                    0
3       Column         0     1     1                    0   r[1]= cursor 0 column 1
4       Ne             2     15    1     BINARY-8       82  if r[1]!=r[2] goto 15
5       Rowid          0     3     0                    0   r[3]=Track.rowid
6       Column         0     1     4                    0   r[4]= cursor 0 column 1
7       Column         0     2     5                    0   r[5]= cursor 0 column 2
8       Column         0     3     6                    0   r[6]= cursor 0 column 3
9       Column         0     4     7                    0   r[7]= cursor 0 column 4
10      Column         0     5     8                    0   r[8]= cursor 0 column 5
11      Column         0     6     9                    0   r[9]= cursor 0 column 6
12      Column         0     7     10                   0   r[10]= cursor 0 column 7
13      Column         0     8     11                   0   r[11]= cursor 0 column 8
14      ResultRow      3     9     0                    0   output=r[3..11]
15    Next           0     3     0                    1
16    Halt           0     0     0                    0
17    Transaction    0     0     66    0              1   usesStmtJournal=0
18    String8        0     2     0     Black Dog      0   r[2]=&#x27;Black Dog&#x27;
19    Goto           0     1     0                    0
</code></pre><p>I&#39;ll be honest, I understand like zero of this. This is what SQLite is doing under the hood. I found the input from Postgres&#39;s explain to be much more readable and actionable. In any case, it&#39;s there and you can anaylze it if you want to. I never look at this so I just wanted to show you that it&#39;s there.</p>
<p>Instead, I use this</p>
<pre><code class="hljs language-sql">EXPLAIN QUERY PLAN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Track <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;Black Dog&#x27;</span>;
<span class="hljs-comment">-- `--SCAN Track</span>
</code></pre><p>Critically, the word <code>SCAN</code> here lets you know that this query is going to look at <em>every</em> row in the table. Now, if you only have 3,000 rows or you only run this query infrequently, who cares, a SCAN is fine. However, if you&#39;re Spotify and you&#39;re scanning 100,000,000 rows every search, then yes, you need to do something about this.</p>
<p>One more fun trick if you&#39;re playing around in the CLI:</p>
<pre><code class="hljs language-sql">.eqp <span class="hljs-keyword">on</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Track <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span><span class="hljs-string">&#x27;Black Dog&#x27;</span>;
</code></pre><p>If you run <code>.eqp on</code>, for the rest of your session it will always show you the query plan when it runs a query. Can be kinda cool to see how SQLite chooses to plan queries.</p>
</div><div class="lesson-links"><a href="/lessons/what-is-unique-to-sqlite/views" class="prev">← Previous</a><a href="/lessons/performance-and-search/indexes" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><script async="" defer="" src="https://a.holt.courses/latest.js"></script><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40" height="32" viewBox="0 0 40 32"><defs><clipPath id="clip-twitter-social"><rect width="40" height="32"></rect></clipPath></defs><g id="twitter-social" clip-path="url(#clip-twitter-social)"><g id="Group_269" data-name="Group 269" transform="translate(-230.23 -1140.849)"><path id="Path_419" data-name="Path 419" d="M266.12,1148.861v1.035a23.092,23.092,0,0,1-1.507,8.1,24.08,24.08,0,0,1-4.475,7.381,22.175,22.175,0,0,1-7.306,5.4,24.129,24.129,0,0,1-10,2.07,23.7,23.7,0,0,1-6.667-.945,22.83,22.83,0,0,1-5.936-2.655q.959.091,1.963.09a16.518,16.518,0,0,0,5.434-.9,17.111,17.111,0,0,0,4.749-2.52,8.275,8.275,0,0,1-4.749-1.643,7.8,7.8,0,0,1-2.877-3.983,8.268,8.268,0,0,0,1.507.135,8.58,8.58,0,0,0,2.146-.27,8.16,8.16,0,0,1-5.685-4.344,8.326,8.326,0,0,1-.89-3.578v-.135a7.775,7.775,0,0,0,3.744,1.035,8.183,8.183,0,0,1-2.671-2.9,7.817,7.817,0,0,1-.982-3.848,7.948,7.948,0,0,1,1.1-4.05,23.53,23.53,0,0,0,16.895,8.46,9.221,9.221,0,0,1-.183-1.845,7.787,7.787,0,0,1,1.1-4.05,8.216,8.216,0,0,1,2.991-2.948,7.991,7.991,0,0,1,4.087-1.1,8.184,8.184,0,0,1,5.982,2.566,16.087,16.087,0,0,0,5.205-1.98,7.784,7.784,0,0,1-1.393,2.588,8.4,8.4,0,0,1-2.215,1.913,16.856,16.856,0,0,0,4.749-1.305A17.032,17.032,0,0,1,266.12,1148.861Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Excercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"title":"EXPLAIN"},"html":"\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Track \u003cspan class=\"hljs-keyword\"\u003eWhere\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Black Dog\u0026#x27;\u003c/span\u003e;\nPRAGMA index_list(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Track\u0026#x27;\u003c/span\u003e);\nEXPLAIN \u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Track \u003cspan class=\"hljs-keyword\"\u003eWhere\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Black Dog\u0026#x27;\u003c/span\u003e;\nEXPLAIN QUERY PLAN \u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Track \u003cspan class=\"hljs-keyword\"\u003eWhere\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Black Dog\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eCREATE\u003c/span\u003e INDEX idx_track_name \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e Track (Name);\nEXPLAIN QUERY PLAN \u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Track \u003cspan class=\"hljs-keyword\"\u003eWhere\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Black Dog\u0026#x27;\u003c/span\u003e;\nPRAGMA index_list(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Track\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGenerally speaking, SQLite is extremely fast even on large datasets. It does a great job of working with large amounts of data even on complicated queries. However occasionally it can use some help when you have heavy queries that you run frequently. Let\u0026#39;s first understand how to look at queries using some fun features built into SQLite.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Track \u003cspan class=\"hljs-keyword\"\u003eWhere\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Black Dog\u0026#x27;\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet\u0026#39;s say we are building an interface that frequently needs to look up tracks by their names. You\u0026#39;d be running queries like this frequently. Right now our Track database has some 3,000 rows in it but imagine if you had Spotify\u0026#39;s database of music. Spotify says it has over 100,000,000 tracks on it, so that query get very slow. Let\u0026#39;s see a few of the ways that SQLite gives you to inspect your queries.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003eEXPLAIN \u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Track \u003cspan class=\"hljs-keyword\"\u003eWhere\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Black Dog\u0026#x27;\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eaddr  opcode         p1    p2    p3    p4             p5  comment\n----  -------------  ----  ----  ----  -------------  --  -------------\n0     Init           0     17    0                    0   Start at 17\n1     OpenRead       0     409   0     9              0   root=409 iDb=0; Track\n2     Rewind         0     16    0                    0\n3       Column         0     1     1                    0   r[1]= cursor 0 column 1\n4       Ne             2     15    1     BINARY-8       82  if r[1]!=r[2] goto 15\n5       Rowid          0     3     0                    0   r[3]=Track.rowid\n6       Column         0     1     4                    0   r[4]= cursor 0 column 1\n7       Column         0     2     5                    0   r[5]= cursor 0 column 2\n8       Column         0     3     6                    0   r[6]= cursor 0 column 3\n9       Column         0     4     7                    0   r[7]= cursor 0 column 4\n10      Column         0     5     8                    0   r[8]= cursor 0 column 5\n11      Column         0     6     9                    0   r[9]= cursor 0 column 6\n12      Column         0     7     10                   0   r[10]= cursor 0 column 7\n13      Column         0     8     11                   0   r[11]= cursor 0 column 8\n14      ResultRow      3     9     0                    0   output=r[3..11]\n15    Next           0     3     0                    1\n16    Halt           0     0     0                    0\n17    Transaction    0     0     66    0              1   usesStmtJournal=0\n18    String8        0     2     0     Black Dog      0   r[2]=\u0026#x27;Black Dog\u0026#x27;\n19    Goto           0     1     0                    0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI\u0026#39;ll be honest, I understand like zero of this. This is what SQLite is doing under the hood. I found the input from Postgres\u0026#39;s explain to be much more readable and actionable. In any case, it\u0026#39;s there and you can anaylze it if you want to. I never look at this so I just wanted to show you that it\u0026#39;s there.\u003c/p\u003e\n\u003cp\u003eInstead, I use this\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003eEXPLAIN QUERY PLAN \u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Track \u003cspan class=\"hljs-keyword\"\u003eWhere\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Black Dog\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e-- `--SCAN Track\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCritically, the word \u003ccode\u003eSCAN\u003c/code\u003e here lets you know that this query is going to look at \u003cem\u003eevery\u003c/em\u003e row in the table. Now, if you only have 3,000 rows or you only run this query infrequently, who cares, a SCAN is fine. However, if you\u0026#39;re Spotify and you\u0026#39;re scanning 100,000,000 rows every search, then yes, you need to do something about this.\u003c/p\u003e\n\u003cp\u003eOne more fun trick if you\u0026#39;re playing around in the CLI:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e.eqp \u003cspan class=\"hljs-keyword\"\u003eon\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Track \u003cspan class=\"hljs-keyword\"\u003eWhere\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Black Dog\u0026#x27;\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you run \u003ccode\u003e.eqp on\u003c/code\u003e, for the rest of your session it will always show you the query plan when it runs a query. Can be kinda cool to see how SQLite chooses to plan queries.\u003c/p\u003e\n","markdown":"\n```sql\nSELECT * FROM Track Where name ='Black Dog';\nPRAGMA index_list('Track');\nEXPLAIN SELECT * FROM Track Where name ='Black Dog';\nEXPLAIN QUERY PLAN SELECT * FROM Track Where name ='Black Dog';\nCREATE INDEX idx_track_name ON Track (Name);\nEXPLAIN QUERY PLAN SELECT * FROM Track Where name ='Black Dog';\nPRAGMA index_list('Track');\n```\n\nGenerally speaking, SQLite is extremely fast even on large datasets. It does a great job of working with large amounts of data even on complicated queries. However occasionally it can use some help when you have heavy queries that you run frequently. Let's first understand how to look at queries using some fun features built into SQLite.\n\n```sql\nSELECT * FROM Track Where name ='Black Dog';\n```\n\nLet's say we are building an interface that frequently needs to look up tracks by their names. You'd be running queries like this frequently. Right now our Track database has some 3,000 rows in it but imagine if you had Spotify's database of music. Spotify says it has over 100,000,000 tracks on it, so that query get very slow. Let's see a few of the ways that SQLite gives you to inspect your queries.\n\n```sql\nEXPLAIN SELECT * FROM Track Where name ='Black Dog';\n```\n\n```\naddr  opcode         p1    p2    p3    p4             p5  comment\n----  -------------  ----  ----  ----  -------------  --  -------------\n0     Init           0     17    0                    0   Start at 17\n1     OpenRead       0     409   0     9              0   root=409 iDb=0; Track\n2     Rewind         0     16    0                    0\n3       Column         0     1     1                    0   r[1]= cursor 0 column 1\n4       Ne             2     15    1     BINARY-8       82  if r[1]!=r[2] goto 15\n5       Rowid          0     3     0                    0   r[3]=Track.rowid\n6       Column         0     1     4                    0   r[4]= cursor 0 column 1\n7       Column         0     2     5                    0   r[5]= cursor 0 column 2\n8       Column         0     3     6                    0   r[6]= cursor 0 column 3\n9       Column         0     4     7                    0   r[7]= cursor 0 column 4\n10      Column         0     5     8                    0   r[8]= cursor 0 column 5\n11      Column         0     6     9                    0   r[9]= cursor 0 column 6\n12      Column         0     7     10                   0   r[10]= cursor 0 column 7\n13      Column         0     8     11                   0   r[11]= cursor 0 column 8\n14      ResultRow      3     9     0                    0   output=r[3..11]\n15    Next           0     3     0                    1\n16    Halt           0     0     0                    0\n17    Transaction    0     0     66    0              1   usesStmtJournal=0\n18    String8        0     2     0     Black Dog      0   r[2]='Black Dog'\n19    Goto           0     1     0                    0\n```\n\nI'll be honest, I understand like zero of this. This is what SQLite is doing under the hood. I found the input from Postgres's explain to be much more readable and actionable. In any case, it's there and you can anaylze it if you want to. I never look at this so I just wanted to show you that it's there.\n\nInstead, I use this\n\n```sql\nEXPLAIN QUERY PLAN SELECT * FROM Track Where name ='Black Dog';\n-- `--SCAN Track\n```\n\nCritically, the word `SCAN` here lets you know that this query is going to look at _every_ row in the table. Now, if you only have 3,000 rows or you only run this query infrequently, who cares, a SCAN is fine. However, if you're Spotify and you're scanning 100,000,000 rows every search, then yes, you need to do something about this.\n\nOne more fun trick if you're playing around in the CLI:\n\n```sql\n.eqp on\nSELECT * FROM Track Where name ='Black Dog';\n```\n\nIf you run `.eqp on`, for the rest of your session it will always show you the query plan when it runs a query. Can be kinda cool to see how SQLite chooses to plan queries.\n","slug":"explain","title":"EXPLAIN","section":"Performance and Search","icon":"gauge-high","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/07-performance-and-search/A-explain.md","nextSlug":"/lessons/performance-and-search/indexes","prevSlug":"/lessons/what-is-unique-to-sqlite/views"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"performance-and-search","slug":"explain"},"buildId":"UVFsG-h6A31FVwYuYsLRa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>