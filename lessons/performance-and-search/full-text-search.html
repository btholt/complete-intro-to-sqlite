<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><link rel="icon" type="image/x-icon" href="/images/favicon.ico"/><title>Full Text Search – Complete Intro to SQLite</title><meta name="description" content="Learn how to build on SQLite with this quick and complete course with Brian Holt. SQLite is a powerful database that is easy to get started with and is a great tool for building both small and large applications."/><meta name="keywords" content="SQL,SQLite,Databases,Web Development,Node.js,JavaScript,Brian Holt,Frontend Masters"/><meta name="og:description" content="Learn how to build on SQLite with this quick and complete course with Brian Holt. SQLite is a powerful database that is easy to get started with and is a great tool for building both small and large applications."/><meta name="og:title" content="Full Text Search – Complete Intro to SQLite"/><meta name="og:image" content="/images/social-share-cover.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="next-head-count" content="14"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/27123e75b7d47aaa.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27123e75b7d47aaa.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-4e7214a60fad8e88.js" defer=""></script><script src="/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/_next/static/chunks/main-be89c515900796e7.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a9fbd9f7480465a3.js" defer=""></script><script src="/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-f133ec3e69124099.js" defer=""></script><script src="/_next/static/UVFsG-h6A31FVwYuYsLRa/_buildManifest.js" defer=""></script><script src="/_next/static/UVFsG-h6A31FVwYuYsLRa/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to SQLite</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/workshops/sqlite/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>What if you&#39;re building an app and you want to be able to search for &quot;black&quot; you expect to get the results Amy Winehouse&#39;s &quot;Back to Black&quot;, the band Black Sabbath, and Metallica&#39;s &quot;Black Album&quot;. Those are three different columns! We could write three LIKE queries or try to hack it around it with something similar, but luckily there&#39;s something that already exists, FTS. FTS stands for full text search and we&#39;re going to be using version 5 of it, FTS5. FTS5 is technically an extension (like the JSON one we&#39;re about to use) but FTS5 is actually shipped bundled in with SQLite now.</p>
<p>FTS5 allows you to run queries that look like <code>SELECT * FROM track_search WHERE track_search MATCH &#39;black&#39;</code>. We get to use MATCH to tell FTS5 to look across its columns. Really cool, right?</p>
<p>Alright, let&#39;s re-use that View we used earlier (easy_tracks). If you don&#39;t have it anymore, here&#39;s the query to recreate it.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> IF <span class="hljs-keyword">EXISTS</span> easy_tracks;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span>
  easy_tracks
<span class="hljs-keyword">AS</span>

<span class="hljs-keyword">SELECT</span>
  t.TrackId <span class="hljs-keyword">as</span> id,
  ar.Name <span class="hljs-keyword">as</span> artist,
  al.Title <span class="hljs-keyword">as</span> album,
  t.Name <span class="hljs-keyword">as</span> track
<span class="hljs-keyword">FROM</span>
  Track t

<span class="hljs-keyword">JOIN</span>
  Album al
<span class="hljs-keyword">ON</span>
  t.AlbumId <span class="hljs-operator">=</span> al.AlbumId

<span class="hljs-keyword">JOIN</span>
  Artist ar
<span class="hljs-keyword">ON</span>
  ar.ArtistId <span class="hljs-operator">=</span> al.ArtistId;
</code></pre><p>Then we need to create the virtual table that will contain the full text search.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> VIRTUAL <span class="hljs-keyword">TABLE</span> track_search <span class="hljs-keyword">USING</span> FTS5(content<span class="hljs-operator">=</span>&quot;easy_tracks&quot;, content_rowid<span class="hljs-operator">=</span><span class="hljs-string">&#x27;id&#x27;</span>, track, album, artist);
</code></pre><ul>
<li>We have to identify where the content is going to com from which will be a table. This table won&#39;t actually contain the rows but only the text searchable table that will have a rowid (which we identified as id; if you just call it rowid we don&#39;t have to tell it which rowid to use.)</li>
<li>We tell it what rows we want to include in full text search. Let&#39;s say we had producers in that table as well but we didn&#39;t want that to be searchable. No problem, you could write a query to select producers that have <code>MATCH &#39;black&#39;</code> and that still works fine! As long as it&#39;s in the view/table you&#39;re selecting from.</li>
<li>We&#39;re choosing to index the view we created earlier but you can definitely do it on normal tables as well.</li>
</ul>
<p>Okay, so because the table doesn&#39;t include the rows itself, we actually have to go populate it. We have to continually keep it up to date because <a href="https://www.sqlite.org/fts5.html#external_content_and_contentless_tables">it does not automatically sync</a> (unlike a view.)</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> track_search <span class="hljs-keyword">SELECT</span> album, artist, track <span class="hljs-keyword">FROM</span> easy_tracks;
</code></pre><p>This is the fastest way. We just use a select statement to grab the correct bits of info and dump it directly into track_search. In theory you could just create a cron job to continually update the virtual table every hour/day/week or whatever meets your customers&#39; needs.</p>
<p>You could get extra fancy and do it with TRIGGERs which we&#39;re not going to cover in this course. If you want to see that, <a href="https://stackoverflow.com/a/69981377">this StackOverflow answer</a> explains exactly how to. If you do that it&#39;ll automatically keep your FTS5 table in sync with your view.</p>
<p>Okay, so let&#39;s run some queries!</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> track_search <span class="hljs-keyword">WHERE</span> track_search <span class="hljs-keyword">MATCH</span> <span class="hljs-string">&#x27;black&#x27;</span>;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> track_search <span class="hljs-keyword">WHERE</span> track_search <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;white&#x27;</span>;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> track_search(<span class="hljs-string">&#x27;red&#x27;</span>);
</code></pre><p>All of these are valid ways of writing the same query. I tend to use the <code>MATCH</code> syntax as it&#39;s very clear that it&#39;s a FTS query.</p>
<h2>There&#39;s more than just match</h2>
<p>I showed you just one of the ways to use MATCH but there&#39;s actually a whole myriad of ways to use it. <a href="https://www.sqlite.org/fts5.html#full_text_query_syntax">Click here</a> to read more of the docs of how you can use special syntax to select words that begin with the search term, ends with it, etc.</p>
<h2>bm25()</h2>
<p>Generally you will want the &quot;best&quot; matches to show up first and the worst matches to show up last. SQLite provides a the bm25 function to do this.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> bm25(track_search), <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> track_search <span class="hljs-keyword">WHERE</span> track_search <span class="hljs-keyword">MATCH</span> <span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> bm25(track_search);
</code></pre><p>The smaller the number is (or the more negative) the better the match is. So this query will give you back all of the matches in order. If you want to learn more or see how the math is done, <a href="https://www.sqlite.org/fts5.html#the_bm25_function">the docs</a> are the best place to look.</p>
</div><div class="lesson-links"><a href="/lessons/performance-and-search/indexes" class="prev">← Previous</a><a href="/lessons/json/sqlite-extensions" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><script async="" defer="" src="https://a.holt.courses/latest.js"></script><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40" height="32" viewBox="0 0 40 32"><defs><clipPath id="clip-twitter-social"><rect width="40" height="32"></rect></clipPath></defs><g id="twitter-social" clip-path="url(#clip-twitter-social)"><g id="Group_269" data-name="Group 269" transform="translate(-230.23 -1140.849)"><path id="Path_419" data-name="Path 419" d="M266.12,1148.861v1.035a23.092,23.092,0,0,1-1.507,8.1,24.08,24.08,0,0,1-4.475,7.381,22.175,22.175,0,0,1-7.306,5.4,24.129,24.129,0,0,1-10,2.07,23.7,23.7,0,0,1-6.667-.945,22.83,22.83,0,0,1-5.936-2.655q.959.091,1.963.09a16.518,16.518,0,0,0,5.434-.9,17.111,17.111,0,0,0,4.749-2.52,8.275,8.275,0,0,1-4.749-1.643,7.8,7.8,0,0,1-2.877-3.983,8.268,8.268,0,0,0,1.507.135,8.58,8.58,0,0,0,2.146-.27,8.16,8.16,0,0,1-5.685-4.344,8.326,8.326,0,0,1-.89-3.578v-.135a7.775,7.775,0,0,0,3.744,1.035,8.183,8.183,0,0,1-2.671-2.9,7.817,7.817,0,0,1-.982-3.848,7.948,7.948,0,0,1,1.1-4.05,23.53,23.53,0,0,0,16.895,8.46,9.221,9.221,0,0,1-.183-1.845,7.787,7.787,0,0,1,1.1-4.05,8.216,8.216,0,0,1,2.991-2.948,7.991,7.991,0,0,1,4.087-1.1,8.184,8.184,0,0,1,5.982,2.566,16.087,16.087,0,0,0,5.205-1.98,7.784,7.784,0,0,1-1.393,2.588,8.4,8.4,0,0,1-2.215,1.913,16.856,16.856,0,0,0,4.749-1.305A17.032,17.032,0,0,1,266.12,1148.861Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Excercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{},"html":"\u003cp\u003eWhat if you\u0026#39;re building an app and you want to be able to search for \u0026quot;black\u0026quot; you expect to get the results Amy Winehouse\u0026#39;s \u0026quot;Back to Black\u0026quot;, the band Black Sabbath, and Metallica\u0026#39;s \u0026quot;Black Album\u0026quot;. Those are three different columns! We could write three LIKE queries or try to hack it around it with something similar, but luckily there\u0026#39;s something that already exists, FTS. FTS stands for full text search and we\u0026#39;re going to be using version 5 of it, FTS5. FTS5 is technically an extension (like the JSON one we\u0026#39;re about to use) but FTS5 is actually shipped bundled in with SQLite now.\u003c/p\u003e\n\u003cp\u003eFTS5 allows you to run queries that look like \u003ccode\u003eSELECT * FROM track_search WHERE track_search MATCH \u0026#39;black\u0026#39;\u003c/code\u003e. We get to use MATCH to tell FTS5 to look across its columns. Really cool, right?\u003c/p\u003e\n\u003cp\u003eAlright, let\u0026#39;s re-use that View we used earlier (easy_tracks). If you don\u0026#39;t have it anymore, here\u0026#39;s the query to recreate it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eDROP\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eVIEW\u003c/span\u003e IF \u003cspan class=\"hljs-keyword\"\u003eEXISTS\u003c/span\u003e easy_tracks;\n\u003cspan class=\"hljs-keyword\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eVIEW\u003c/span\u003e\n  easy_tracks\n\u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n  t.TrackId \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e id,\n  ar.Name \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e artist,\n  al.Title \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e album,\n  t.Name \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e track\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n  Track t\n\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n  Album al\n\u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n  t.AlbumId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e al.AlbumId\n\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n  Artist ar\n\u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n  ar.ArtistId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e al.ArtistId;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we need to create the virtual table that will contain the full text search.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eCREATE\u003c/span\u003e VIRTUAL \u003cspan class=\"hljs-keyword\"\u003eTABLE\u003c/span\u003e track_search \u003cspan class=\"hljs-keyword\"\u003eUSING\u003c/span\u003e FTS5(content\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u0026quot;easy_tracks\u0026quot;, content_rowid\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;id\u0026#x27;\u003c/span\u003e, track, album, artist);\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eWe have to identify where the content is going to com from which will be a table. This table won\u0026#39;t actually contain the rows but only the text searchable table that will have a rowid (which we identified as id; if you just call it rowid we don\u0026#39;t have to tell it which rowid to use.)\u003c/li\u003e\n\u003cli\u003eWe tell it what rows we want to include in full text search. Let\u0026#39;s say we had producers in that table as well but we didn\u0026#39;t want that to be searchable. No problem, you could write a query to select producers that have \u003ccode\u003eMATCH \u0026#39;black\u0026#39;\u003c/code\u003e and that still works fine! As long as it\u0026#39;s in the view/table you\u0026#39;re selecting from.\u003c/li\u003e\n\u003cli\u003eWe\u0026#39;re choosing to index the view we created earlier but you can definitely do it on normal tables as well.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOkay, so because the table doesn\u0026#39;t include the rows itself, we actually have to go populate it. We have to continually keep it up to date because \u003ca href=\"https://www.sqlite.org/fts5.html#external_content_and_contentless_tables\"\u003eit does not automatically sync\u003c/a\u003e (unlike a view.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eINTO\u003c/span\u003e track_search \u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e album, artist, track \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e easy_tracks;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is the fastest way. We just use a select statement to grab the correct bits of info and dump it directly into track_search. In theory you could just create a cron job to continually update the virtual table every hour/day/week or whatever meets your customers\u0026#39; needs.\u003c/p\u003e\n\u003cp\u003eYou could get extra fancy and do it with TRIGGERs which we\u0026#39;re not going to cover in this course. If you want to see that, \u003ca href=\"https://stackoverflow.com/a/69981377\"\u003ethis StackOverflow answer\u003c/a\u003e explains exactly how to. If you do that it\u0026#39;ll automatically keep your FTS5 table in sync with your view.\u003c/p\u003e\n\u003cp\u003eOkay, so let\u0026#39;s run some queries!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e track_search \u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e track_search \u003cspan class=\"hljs-keyword\"\u003eMATCH\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;black\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e track_search \u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e track_search \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;white\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e track_search(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;red\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAll of these are valid ways of writing the same query. I tend to use the \u003ccode\u003eMATCH\u003c/code\u003e syntax as it\u0026#39;s very clear that it\u0026#39;s a FTS query.\u003c/p\u003e\n\u003ch2\u003eThere\u0026#39;s more than just match\u003c/h2\u003e\n\u003cp\u003eI showed you just one of the ways to use MATCH but there\u0026#39;s actually a whole myriad of ways to use it. \u003ca href=\"https://www.sqlite.org/fts5.html#full_text_query_syntax\"\u003eClick here\u003c/a\u003e to read more of the docs of how you can use special syntax to select words that begin with the search term, ends with it, etc.\u003c/p\u003e\n\u003ch2\u003ebm25()\u003c/h2\u003e\n\u003cp\u003eGenerally you will want the \u0026quot;best\u0026quot; matches to show up first and the worst matches to show up last. SQLite provides a the bm25 function to do this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e bm25(track_search), \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e track_search \u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e track_search \u003cspan class=\"hljs-keyword\"\u003eMATCH\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;black\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e bm25(track_search);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe smaller the number is (or the more negative) the better the match is. So this query will give you back all of the matches in order. If you want to learn more or see how the math is done, \u003ca href=\"https://www.sqlite.org/fts5.html#the_bm25_function\"\u003ethe docs\u003c/a\u003e are the best place to look.\u003c/p\u003e\n","markdown":"What if you're building an app and you want to be able to search for \"black\" you expect to get the results Amy Winehouse's \"Back to Black\", the band Black Sabbath, and Metallica's \"Black Album\". Those are three different columns! We could write three LIKE queries or try to hack it around it with something similar, but luckily there's something that already exists, FTS. FTS stands for full text search and we're going to be using version 5 of it, FTS5. FTS5 is technically an extension (like the JSON one we're about to use) but FTS5 is actually shipped bundled in with SQLite now.\n\nFTS5 allows you to run queries that look like `SELECT * FROM track_search WHERE track_search MATCH 'black'`. We get to use MATCH to tell FTS5 to look across its columns. Really cool, right?\n\nAlright, let's re-use that View we used earlier (easy_tracks). If you don't have it anymore, here's the query to recreate it.\n\n```sql\nDROP VIEW IF EXISTS easy_tracks;\nCREATE VIEW\n  easy_tracks\nAS\n\nSELECT\n  t.TrackId as id,\n  ar.Name as artist,\n  al.Title as album,\n  t.Name as track\nFROM\n  Track t\n\nJOIN\n  Album al\nON\n  t.AlbumId = al.AlbumId\n\nJOIN\n  Artist ar\nON\n  ar.ArtistId = al.ArtistId;\n```\n\nThen we need to create the virtual table that will contain the full text search.\n\n```sql\nCREATE VIRTUAL TABLE track_search USING FTS5(content=\"easy_tracks\", content_rowid='id', track, album, artist);\n```\n\n- We have to identify where the content is going to com from which will be a table. This table won't actually contain the rows but only the text searchable table that will have a rowid (which we identified as id; if you just call it rowid we don't have to tell it which rowid to use.)\n- We tell it what rows we want to include in full text search. Let's say we had producers in that table as well but we didn't want that to be searchable. No problem, you could write a query to select producers that have `MATCH 'black'` and that still works fine! As long as it's in the view/table you're selecting from.\n- We're choosing to index the view we created earlier but you can definitely do it on normal tables as well.\n\nOkay, so because the table doesn't include the rows itself, we actually have to go populate it. We have to continually keep it up to date because [it does not automatically sync][sync] (unlike a view.)\n\n```sql\nINSERT INTO track_search SELECT album, artist, track FROM easy_tracks;\n```\n\nThis is the fastest way. We just use a select statement to grab the correct bits of info and dump it directly into track_search. In theory you could just create a cron job to continually update the virtual table every hour/day/week or whatever meets your customers' needs.\n\nYou could get extra fancy and do it with TRIGGERs which we're not going to cover in this course. If you want to see that, [this StackOverflow answer][stack-overflow] explains exactly how to. If you do that it'll automatically keep your FTS5 table in sync with your view.\n\nOkay, so let's run some queries!\n\n```sql\nSELECT * FROM track_search WHERE track_search MATCH 'black';\nSELECT * FROM track_search WHERE track_search = 'white';\nSELECT * FROM track_search('red');\n```\n\nAll of these are valid ways of writing the same query. I tend to use the `MATCH` syntax as it's very clear that it's a FTS query.\n\n## There's more than just match\n\nI showed you just one of the ways to use MATCH but there's actually a whole myriad of ways to use it. [Click here][syntax] to read more of the docs of how you can use special syntax to select words that begin with the search term, ends with it, etc.\n\n## bm25()\n\nGenerally you will want the \"best\" matches to show up first and the worst matches to show up last. SQLite provides a the bm25 function to do this.\n\n```sql\nSELECT bm25(track_search), * FROM track_search WHERE track_search MATCH 'black' ORDER BY bm25(track_search);\n```\n\nThe smaller the number is (or the more negative) the better the match is. So this query will give you back all of the matches in order. If you want to learn more or see how the math is done, [the docs][bm25] are the best place to look.\n\n[sync]: https://www.sqlite.org/fts5.html#external_content_and_contentless_tables\n[stack-overflow]: https://stackoverflow.com/a/69981377\n[syntax]: https://www.sqlite.org/fts5.html#full_text_query_syntax\n[bm25]: https://www.sqlite.org/fts5.html#the_bm25_function\n","slug":"full-text-search","title":"Full Text Search","section":"Performance and Search","icon":"gauge-high","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/07-performance-and-search/C-full-text-search.md","nextSlug":"/lessons/json/sqlite-extensions","prevSlug":"/lessons/performance-and-search/indexes"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"performance-and-search","slug":"full-text-search"},"buildId":"UVFsG-h6A31FVwYuYsLRa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>