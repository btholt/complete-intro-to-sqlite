<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><link rel="icon" type="image/x-icon" href="/images/favicon.ico"/><title>Relational Data – Complete Intro to SQLite</title><meta name="description" content="Learn how to build on SQLite with this quick and complete course with Brian Holt. SQLite is a powerful database that is easy to get started with and is a great tool for building both small and large applications."/><meta name="keywords" content="SQL,SQLite,Databases,Web Development,Node.js,JavaScript,Brian Holt,Frontend Masters"/><meta name="og:description" content="Learn how to build on SQLite with this quick and complete course with Brian Holt. SQLite is a powerful database that is easy to get started with and is a great tool for building both small and large applications."/><meta name="og:title" content="Relational Data – Complete Intro to SQLite"/><meta name="og:image" content="/images/social-share-cover.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="next-head-count" content="14"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/27123e75b7d47aaa.css" as="style"/><link rel="stylesheet" href="/_next/static/css/27123e75b7d47aaa.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-4e7214a60fad8e88.js" defer=""></script><script src="/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/_next/static/chunks/main-be89c515900796e7.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a9fbd9f7480465a3.js" defer=""></script><script src="/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-f133ec3e69124099.js" defer=""></script><script src="/_next/static/UVFsG-h6A31FVwYuYsLRa/_buildManifest.js" defer=""></script><script src="/_next/static/UVFsG-h6A31FVwYuYsLRa/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to SQLite</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/workshops/sqlite/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>So far we&#39;ve done a one-to-one matching of records. We&#39;ve used a record in a database to represent one item: one band member, band, etc.</p>
<p>Now we&#39;re going to get into records that can relate to each other. Let&#39;s think about albums. An album has multiple tracks. That <strong>has</strong> word is key here. It means there is a relationship. A single album has many tracks. This is a one-to-many relationship – one album has multiple tracks. Those tracks belong to that album. A track does not belong to multiple albums (in theory you could model this differently but let&#39;s say we choose to model it this way.)</p>
<p>A band member can belong to multiple bands, and a band has multiple members. Dave Grohl has been in Nirvana, Foo Fighters, and Them Crooked Vultures. This kind of relationship is called many-to-many. Recipes and ingredients would be another good example of this. A recipe has many ingredients, and an ingredient can belong to many recipes.</p>
<p>There can also exist one-to-one relationships but in general, you would just make those the same record altogether. You could split up the type and title into two tables, but why would you? Then you have a data sync problem. What if a band renames themselves? Ex: On a Friday → Radiohead, Prince → The Artist Formerly Known as Prince, The Quarrymen → The Beatles. Anyone who has ever tried to manually keep data in sync in two+ places knows eventually you will have issues.</p>
<p>Luckily we can use relational data to have one table of bands and one table of albums.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Album LIMIT <span class="hljs-number">5</span>;
</code></pre><p>Notice that we&#39;re just getting ArtistId (a number) instead of the actual name of the band. That&#39;s not what we want, we want to see the name of the album and the name of the band. Enter JOINs. This allows us to join two tables based on common data. Let&#39;s see how to do that.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
    Artist.Name, Album.Title
<span class="hljs-keyword">FROM</span>
    Album
<span class="hljs-keyword">JOIN</span>
    Artist <span class="hljs-keyword">ON</span>
        Album.ArtistId <span class="hljs-operator">=</span> Artist.ArtistId
LIMIT <span class="hljs-number">5</span>;
</code></pre><blockquote>
<p>Once we start getting into longer queries (especially when in code) I start spacing it out using new lines to make it easier to read. Makes it easier to understand at a glance.</p>
</blockquote>
<p>We JOIN&#39;d the Artist table to the Album table based on them sharing a common ArtistId. Pretty cool, right? Let&#39;s look at a few more tricks here.</p>
<h2>Table Aliases</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
    b.Name, a.Title
<span class="hljs-keyword">FROM</span>
    Album a
<span class="hljs-keyword">JOIN</span>
    Artist b <span class="hljs-keyword">ON</span>
        a.ArtistId <span class="hljs-operator">=</span> b.ArtistId
LIMIT <span class="hljs-number">5</span>;
</code></pre><p>You can give tables aliases so they&#39;re easier to refer to. Some of the table names can get quite long so this can make it more readable. In this case, I&#39;d argue that the single-letter variable names make it <em>less</em> readable, that&#39;s up to you.</p>
<h2>You can use WHERE!</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
    Artist.Name, Album.Title
<span class="hljs-keyword">FROM</span>
    Album
<span class="hljs-keyword">JOIN</span>
    Artist <span class="hljs-keyword">ON</span>
        Album.ArtistId <span class="hljs-operator">=</span> Artist.ArtistId
<span class="hljs-keyword">WHERE</span>
    Artist.Name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Nirvana&#x27;</span>;

<span class="hljs-keyword">SELECT</span>
    Artist.Name, Album.Title
<span class="hljs-keyword">FROM</span>
    Album
<span class="hljs-keyword">JOIN</span>
    Artist <span class="hljs-keyword">ON</span>
        Album.ArtistId <span class="hljs-operator">=</span> Artist.ArtistId
<span class="hljs-keyword">WHERE</span>
    Album.Title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;IV&#x27;</span>;

<span class="hljs-keyword">SELECT</span>
    Artist.Name, Album.Title
<span class="hljs-keyword">FROM</span>
    Album
<span class="hljs-keyword">JOIN</span>
    Artist <span class="hljs-keyword">ON</span>
        Album.ArtistId <span class="hljs-operator">=</span> Artist.ArtistId
<span class="hljs-keyword">WHERE</span>
    Album.Title <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%live%&#x27;</span>;
</code></pre><p>As you can see, once you set up the JOIN and how you want to join the tables together, you can start filtering your results based on either table. The first query we asked for only Nirvana&#39;s albums, the second is just albums named <code>IV</code>, and the third we&#39;re asking for any album that <code>live</code> in it.</p>
<h2>Joining more than two tables</h2>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
    Artist.Name, Album.Title, Track.Name
<span class="hljs-keyword">FROM</span>
    Album
<span class="hljs-keyword">JOIN</span>
    Artist <span class="hljs-keyword">ON</span>
        Album.ArtistId <span class="hljs-operator">=</span> Artist.ArtistId
<span class="hljs-keyword">JOIN</span>
    Track <span class="hljs-keyword">ON</span>
        Track.AlbumId <span class="hljs-operator">=</span> Album.AlbumId
<span class="hljs-keyword">WHERE</span>
    Album.Title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;IV&#x27;</span>;
</code></pre><p>As you can see, you can just keep joining tables as long you have ways to join the table.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span>
    Artist.Name, Album.Title, Track.Name, Genre.Name
<span class="hljs-keyword">FROM</span>
    Album
<span class="hljs-keyword">JOIN</span>
    Artist <span class="hljs-keyword">ON</span>
        Album.ArtistId <span class="hljs-operator">=</span> Artist.ArtistId
<span class="hljs-keyword">JOIN</span>
    Track <span class="hljs-keyword">ON</span>
        Track.AlbumId <span class="hljs-operator">=</span> Album.AlbumId
<span class="hljs-keyword">JOIN</span>
    Genre <span class="hljs-keyword">ON</span>
        Track.GenreId <span class="hljs-operator">=</span> Genre.GenreId
<span class="hljs-keyword">WHERE</span>
    Artist.Name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Foo Fighters&#x27;</span>;
</code></pre><p>You can just keep joining as you need to.</p>
</div><div class="lesson-links"><a href="/lessons/basic-sql/tables" class="prev">← Previous</a><a href="/lessons/intermediate-sql/other-types-of-joins" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><script async="" defer="" src="https://a.holt.courses/latest.js"></script><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40" height="32" viewBox="0 0 40 32"><defs><clipPath id="clip-twitter-social"><rect width="40" height="32"></rect></clipPath></defs><g id="twitter-social" clip-path="url(#clip-twitter-social)"><g id="Group_269" data-name="Group 269" transform="translate(-230.23 -1140.849)"><path id="Path_419" data-name="Path 419" d="M266.12,1148.861v1.035a23.092,23.092,0,0,1-1.507,8.1,24.08,24.08,0,0,1-4.475,7.381,22.175,22.175,0,0,1-7.306,5.4,24.129,24.129,0,0,1-10,2.07,23.7,23.7,0,0,1-6.667-.945,22.83,22.83,0,0,1-5.936-2.655q.959.091,1.963.09a16.518,16.518,0,0,0,5.434-.9,17.111,17.111,0,0,0,4.749-2.52,8.275,8.275,0,0,1-4.749-1.643,7.8,7.8,0,0,1-2.877-3.983,8.268,8.268,0,0,0,1.507.135,8.58,8.58,0,0,0,2.146-.27,8.16,8.16,0,0,1-5.685-4.344,8.326,8.326,0,0,1-.89-3.578v-.135a7.775,7.775,0,0,0,3.744,1.035,8.183,8.183,0,0,1-2.671-2.9,7.817,7.817,0,0,1-.982-3.848,7.948,7.948,0,0,1,1.1-4.05,23.53,23.53,0,0,0,16.895,8.46,9.221,9.221,0,0,1-.183-1.845,7.787,7.787,0,0,1,1.1-4.05,8.216,8.216,0,0,1,2.991-2.948,7.991,7.991,0,0,1,4.087-1.1,8.184,8.184,0,0,1,5.982,2.566,16.087,16.087,0,0,0,5.205-1.98,7.784,7.784,0,0,1-1.393,2.588,8.4,8.4,0,0,1-2.215,1.913,16.856,16.856,0,0,0,4.749-1.305A17.032,17.032,0,0,1,266.12,1148.861Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Excercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{},"html":"\u003cp\u003eSo far we\u0026#39;ve done a one-to-one matching of records. We\u0026#39;ve used a record in a database to represent one item: one band member, band, etc.\u003c/p\u003e\n\u003cp\u003eNow we\u0026#39;re going to get into records that can relate to each other. Let\u0026#39;s think about albums. An album has multiple tracks. That \u003cstrong\u003ehas\u003c/strong\u003e word is key here. It means there is a relationship. A single album has many tracks. This is a one-to-many relationship – one album has multiple tracks. Those tracks belong to that album. A track does not belong to multiple albums (in theory you could model this differently but let\u0026#39;s say we choose to model it this way.)\u003c/p\u003e\n\u003cp\u003eA band member can belong to multiple bands, and a band has multiple members. Dave Grohl has been in Nirvana, Foo Fighters, and Them Crooked Vultures. This kind of relationship is called many-to-many. Recipes and ingredients would be another good example of this. A recipe has many ingredients, and an ingredient can belong to many recipes.\u003c/p\u003e\n\u003cp\u003eThere can also exist one-to-one relationships but in general, you would just make those the same record altogether. You could split up the type and title into two tables, but why would you? Then you have a data sync problem. What if a band renames themselves? Ex: On a Friday → Radiohead, Prince → The Artist Formerly Known as Prince, The Quarrymen → The Beatles. Anyone who has ever tried to manually keep data in sync in two+ places knows eventually you will have issues.\u003c/p\u003e\n\u003cp\u003eLuckily we can use relational data to have one table of bands and one table of albums.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e Album LIMIT \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that we\u0026#39;re just getting ArtistId (a number) instead of the actual name of the band. That\u0026#39;s not what we want, we want to see the name of the album and the name of the band. Enter JOINs. This allows us to join two tables based on common data. Let\u0026#39;s see how to do that.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n    Artist.Name, Album.Title\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n    Album\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Artist \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Album.ArtistId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Artist.ArtistId\nLIMIT \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003eOnce we start getting into longer queries (especially when in code) I start spacing it out using new lines to make it easier to read. Makes it easier to understand at a glance.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWe JOIN\u0026#39;d the Artist table to the Album table based on them sharing a common ArtistId. Pretty cool, right? Let\u0026#39;s look at a few more tricks here.\u003c/p\u003e\n\u003ch2\u003eTable Aliases\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n    b.Name, a.Title\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n    Album a\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Artist b \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        a.ArtistId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e b.ArtistId\nLIMIT \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can give tables aliases so they\u0026#39;re easier to refer to. Some of the table names can get quite long so this can make it more readable. In this case, I\u0026#39;d argue that the single-letter variable names make it \u003cem\u003eless\u003c/em\u003e readable, that\u0026#39;s up to you.\u003c/p\u003e\n\u003ch2\u003eYou can use WHERE!\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n    Artist.Name, Album.Title\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n    Album\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Artist \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Album.ArtistId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Artist.ArtistId\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e\n    Artist.Name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Nirvana\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n    Artist.Name, Album.Title\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n    Album\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Artist \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Album.ArtistId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Artist.ArtistId\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e\n    Album.Title \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;IV\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n    Artist.Name, Album.Title\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n    Album\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Artist \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Album.ArtistId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Artist.ArtistId\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e\n    Album.Title \u003cspan class=\"hljs-keyword\"\u003eLIKE\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;%live%\u0026#x27;\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see, once you set up the JOIN and how you want to join the tables together, you can start filtering your results based on either table. The first query we asked for only Nirvana\u0026#39;s albums, the second is just albums named \u003ccode\u003eIV\u003c/code\u003e, and the third we\u0026#39;re asking for any album that \u003ccode\u003elive\u003c/code\u003e in it.\u003c/p\u003e\n\u003ch2\u003eJoining more than two tables\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n    Artist.Name, Album.Title, Track.Name\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n    Album\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Artist \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Album.ArtistId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Artist.ArtistId\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Track \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Track.AlbumId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Album.AlbumId\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e\n    Album.Title \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;IV\u0026#x27;\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see, you can just keep joining tables as long you have ways to join the table.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e\n    Artist.Name, Album.Title, Track.Name, Genre.Name\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n    Album\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Artist \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Album.ArtistId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Artist.ArtistId\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Track \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Track.AlbumId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Album.AlbumId\n\u003cspan class=\"hljs-keyword\"\u003eJOIN\u003c/span\u003e\n    Genre \u003cspan class=\"hljs-keyword\"\u003eON\u003c/span\u003e\n        Track.GenreId \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Genre.GenreId\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e\n    Artist.Name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Foo Fighters\u0026#x27;\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can just keep joining as you need to.\u003c/p\u003e\n","markdown":"So far we've done a one-to-one matching of records. We've used a record in a database to represent one item: one band member, band, etc.\n\nNow we're going to get into records that can relate to each other. Let's think about albums. An album has multiple tracks. That **has** word is key here. It means there is a relationship. A single album has many tracks. This is a one-to-many relationship – one album has multiple tracks. Those tracks belong to that album. A track does not belong to multiple albums (in theory you could model this differently but let's say we choose to model it this way.)\n\nA band member can belong to multiple bands, and a band has multiple members. Dave Grohl has been in Nirvana, Foo Fighters, and Them Crooked Vultures. This kind of relationship is called many-to-many. Recipes and ingredients would be another good example of this. A recipe has many ingredients, and an ingredient can belong to many recipes.\n\nThere can also exist one-to-one relationships but in general, you would just make those the same record altogether. You could split up the type and title into two tables, but why would you? Then you have a data sync problem. What if a band renames themselves? Ex: On a Friday → Radiohead, Prince → The Artist Formerly Known as Prince, The Quarrymen → The Beatles. Anyone who has ever tried to manually keep data in sync in two+ places knows eventually you will have issues.\n\nLuckily we can use relational data to have one table of bands and one table of albums.\n\n```sql\nSELECT * FROM Album LIMIT 5;\n```\n\nNotice that we're just getting ArtistId (a number) instead of the actual name of the band. That's not what we want, we want to see the name of the album and the name of the band. Enter JOINs. This allows us to join two tables based on common data. Let's see how to do that.\n\n```sql\nSELECT\n    Artist.Name, Album.Title\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nLIMIT 5;\n```\n\n\u003e Once we start getting into longer queries (especially when in code) I start spacing it out using new lines to make it easier to read. Makes it easier to understand at a glance.\n\nWe JOIN'd the Artist table to the Album table based on them sharing a common ArtistId. Pretty cool, right? Let's look at a few more tricks here.\n\n## Table Aliases\n\n```sql\nSELECT\n    b.Name, a.Title\nFROM\n    Album a\nJOIN\n    Artist b ON\n        a.ArtistId = b.ArtistId\nLIMIT 5;\n```\n\nYou can give tables aliases so they're easier to refer to. Some of the table names can get quite long so this can make it more readable. In this case, I'd argue that the single-letter variable names make it _less_ readable, that's up to you.\n\n## You can use WHERE!\n\n```sql\nSELECT\n    Artist.Name, Album.Title\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nWHERE\n    Artist.Name = 'Nirvana';\n\nSELECT\n    Artist.Name, Album.Title\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nWHERE\n    Album.Title = 'IV';\n\nSELECT\n    Artist.Name, Album.Title\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nWHERE\n    Album.Title LIKE '%live%';\n```\n\nAs you can see, once you set up the JOIN and how you want to join the tables together, you can start filtering your results based on either table. The first query we asked for only Nirvana's albums, the second is just albums named `IV`, and the third we're asking for any album that `live` in it.\n\n## Joining more than two tables\n\n```sql\nSELECT\n    Artist.Name, Album.Title, Track.Name\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nJOIN\n    Track ON\n        Track.AlbumId = Album.AlbumId\nWHERE\n    Album.Title = 'IV';\n```\n\nAs you can see, you can just keep joining tables as long you have ways to join the table.\n\n```sql\nSELECT\n    Artist.Name, Album.Title, Track.Name, Genre.Name\nFROM\n    Album\nJOIN\n    Artist ON\n        Album.ArtistId = Artist.ArtistId\nJOIN\n    Track ON\n        Track.AlbumId = Album.AlbumId\nJOIN\n    Genre ON\n        Track.GenreId = Genre.GenreId\nWHERE\n    Artist.Name = 'Foo Fighters';\n```\n\nYou can just keep joining as you need to.\n","slug":"relational-data","title":"Relational Data","section":"Intermediate SQL","icon":"table","filePath":"/home/runner/work/complete-intro-to-sqlite/complete-intro-to-sqlite/lessons/04-intermediate-sql/A-relational-data.md","nextSlug":"/lessons/intermediate-sql/other-types-of-joins","prevSlug":"/lessons/basic-sql/tables"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"intermediate-sql","slug":"relational-data"},"buildId":"UVFsG-h6A31FVwYuYsLRa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>